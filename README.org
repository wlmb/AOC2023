* Advent of code
Trying my luck for the first time with the [[https://adventofcode.com/2023/about][Advent of Code]] 2023.
** Day 1
https://adventofcode.com/2023/day/1
*** Task a
Use non-greedy regular expressions to get the first and last digits of
each row

#+begin_src perl :tangle 1a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
while(<>){
    /^.*?(\d)/ and my $f=$1 or die;
    /.*(\d).*?$/ and my $l=$1 or die;
    $tot += "$f$l";
}
say $tot;
#+end_src
*** Task b
Make a regular expression to identify digits and digit names.
#+begin_src perl :tangle 1b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
my @digits=qw(one two three four five six seven eight nine);
my $i=1;
my %digit;
$digit{$_}=$i++ for @digits;
$digit{$_}=$_ for 0..9;
my $digit=join "|", @digits, '\d';
my $first=qr"^.*?($digit)"i;
my $last=qr".*($digit).*?$"i;
while(<>){
    /$first/ and my $f=$1 or die;
    /$last/ and my $l=$1 or die;
    $tot += "$digit{$f}$digit{$l}";
}
say $tot;
#+end_src
** Day 2
https://adventofcode.com/2023/day/2
*** Task a
Use regular expressions to obtain game ids. Split to obtain the
subsets of cubes. Use a regular expression to obtain the number of
cubes of each color and check if there are enough cubes in the bag.
#+begin_src perl :tangle 2a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum possible game ids for 12 red cubes, 13 green cubes, and 14 blue cubes
use v5.36;
my %available=(red=>12, green=>13, blue=>14);
my $total=0;
while(<>){
    s/Game\s*(\d+):\s*// or die;
    my $id=$1;
    my $impossible=0;
    SUBSET: for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    $impossible=1,last SUBSET if $quantity>$available{$color};
	}
    }
    $total += $id unless $impossible;
}
say $total;
#+end_src
*** Task b
Use a regular expression and split to obtain the subsets. Adjust the
minimum number of cubes necessary to fullfill all samples, multiply
them and add.

#+begin_src perl :tangle 2b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum minimum powers of games
use v5.36;
use List::Util qw(product);
my $total=0;
while(<>){
    s/Game\s*\d+:\s*// or die;
    my %minima=(red=>0, green=>0, blue=>0);
    for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    ($_<$quantity) && ($_=$quantity) for $minima{$color};
	}
    }
    my $product=product values %minima;
    $total += $product;
}
say $total;
#+end_src
** Day 3
https://adventofcode.com/2023/day/3
*** Task a
Read the schematics into an array. Add dots "." at the boundaries as
guards. For each symbol, mark as valid its nearest
neighbors. Accumulate all numbers, i.e., strings of digits, that
overlap a valid cell.

#+begin_src perl :tangle 3a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $symbol=qr([^\.\d]);
my @schematic;
my @valid; # valid sites
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    push @schematic, [@row];
    push @valid, [(0) x $width];
}
push @schematic, [(".") x $width];  # add initial, final boundaries
unshift @schematic, [(".") x $width];
push @valid, [(0) x $width];
unshift @valid, [(0) x $width];
for my $i(1..@schematic-2){
    for my $j(1..$width-2){
	next unless $schematic[$i][$j]=~/$symbol/;
	for my $k(-1,0,1){     # validate neighbors of symbols
	    for my $l(-1,0,1){
		$valid[$i+$k][$j+$l]=1;
	    }
	}
    }
}
my $total=0;
for my $i(1..@schematic-2){
    my @row=@{$schematic[$i]};
    my @valid_row=@{$valid[$i]};
    my $number=0;
    my $valid=0;
    for my $j(1..$width-2){
	$valid||=$valid_row[$j], $number=10*$number+$row[$j], next if $row[$j]=~/\d/;
	$total+=$number if $valid;
	$number=0;
	$valid=0
    }
    $total+=$number if $valid;
    $number=0;
    $valid=0;
}
say $total;
#+end_src
*** Task b
Index all part numbers, i.e., strings of digits, by pushing them into
an array. For each gear, identify the part indices of the neighboring
parts. If there are exactly two, multiply them and accumulate the product.

#+begin_src perl :tangle 3b.pl :shebang #!/usr/bin/env perl
use v5.36;
my $gear=qr(\*);
my @schematic;
my @parts;
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    my $number;
    for(@row){
	if(/\d/){
	    $number//=0;
	    $number=10*$number+$_;
	    $_=@parts; # part index
	}else{
	    push @parts, $number if defined $number;
	    undef $number;
	}
    }
    push @schematic, [@row];
}
push @schematic, [(".") x @{$schematic[0]}];  # add initial, final boundaries
unshift @schematic, [(".") x @{$schematic[0]}];
my $total=0;
for my $i(1..@schematic-2){
    for my $j(1..$width-1){
	next unless $schematic[$i][$j]=~/$gear/;
	my %neighbors;
	for my $k(-1,0,1){
	    for my $l(-1,0,1){
		$neighbors{$schematic[$i+$k][$j+$l]}=1 if $schematic[$i+$k][$j+$l]=~/\d/;
	    }
	}
	my @neighbors=keys %neighbors;
	next unless @neighbors==2; # exactly two neighbors
	$total+=$parts[$neighbors[0]]*$parts[$neighbors[1]];
    }
}
say $total;
#+end_src
** Day 4
https://adventofcode.com/2023/day/4
*** Task a
I use a regular expression to throw away the card numbers and separate
the winning from the card numbers. I split those numbers on space. I
make a hash of winning numbers to check against the card numbers and
find how many matches m I get. If m==0, the score of that card is 0,
otherwise, it is 2^{m-1}.

#+begin_src perl :tangle 4a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $total=0;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    my $score=0;
    $score=1<<($matches-1) if $matches;
    $total += $score;
}
say $total;
#+end_src

*** Task b
I use the previous task to obtain how many numbers match the winning
numbers of each card and save that in an array. I start with one card
each. For each card number I keep an array of how many cards I have
and add that many cards to the number of following cards, according to
the score. I guess the code is clearer than this description.
#+begin_src perl :tangle 4b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(sum0);
my @scores;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    push @scores, $matches;
}
my @cards=(1) x @scores;
for(0..@scores-1){
    my $multiplier=$cards[$_];
    $cards[$_] += $multiplier for ($_+1..$_+$scores[$_]);
}
my $cards=sum0 @cards;
say $cards;
#+end_src
