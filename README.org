* Advent of code
Trying my luck for the first time with the [[https://adventofcode.com/2023/about][Advent of Code]] 2023.
** Day 1
https://adventofcode.com/2023/day/1
*** Task a
Use non-greedy regular expressions to get the first and last digits of
each row

#+begin_src perl :tangle 1a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
while(<>){
    /^.*?(\d)/ and my $f=$1 or die;
    /.*(\d).*?$/ and my $l=$1 or die;
    $tot += "$f$l";
}
say $tot;
#+end_src
*** Task b
Make a regular expression to identify digits and digit names.
#+begin_src perl :tangle 1b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
my @digits=qw(one two three four five six seven eight nine);
my $i=1;
my %digit;
$digit{$_}=$i++ for @digits;
$digit{$_}=$_ for 0..9;
my $digit=join "|", @digits, '\d';
my $first=qr"^.*?($digit)"i;
my $last=qr".*($digit).*?$"i;
while(<>){
    /$first/ and my $f=$1 or die;
    /$last/ and my $l=$1 or die;
    $tot += "$digit{$f}$digit{$l}";
}
say $tot;
#+end_src
** Day 2
https://adventofcode.com/2023/day/2
*** Task a
Use regular expressions to obtain game ids. Split to obtain the
subsets of cubes. Use a regular expression to obtain the number of
cubes of each color and check if there are enough cubes in the bag.
#+begin_src perl :tangle 2a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum possible game ids for 12 red cubes, 13 green cubes, and 14 blue cubes
use v5.36;
my %available=(red=>12, green=>13, blue=>14);
my $total=0;
while(<>){
    s/Game\s*(\d+):\s*// or die;
    my $id=$1;
    my $impossible=0;
    SUBSET: for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    $impossible=1,last SUBSET if $quantity>$available{$color};
	}
    }
    $total += $id unless $impossible;
}
say $total;
#+end_src
*** Task b
Use a regular expression and split to obtain the subsets. Adjust the
minimum number of cubes necessary to fullfill all samples, multiply
them and add.

#+begin_src perl :tangle 2b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum minimum powers of games
use v5.36;
use List::Util qw(product);
my $total=0;
while(<>){
    s/Game\s*\d+:\s*// or die;
    my %minima=(red=>0, green=>0, blue=>0);
    for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    ($_<$quantity) && ($_=$quantity) for $minima{$color};
	}
    }
    my $product=product values %minima;
    $total += $product;
}
say $total;
#+end_src
** Day 3
https://adventofcode.com/2023/day/3
*** Task a
Read the schematics into an array. Add dots "." at the boundaries as
guards. For each symbol, mark as valid its nearest
neighbors. Accumulate all numbers, i.e., strings of digits, that
overlap a valid cell.

#+begin_src perl :tangle 3a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $symbol=qr([^\.\d]);
my @schematic;
my @valid; # valid sites
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    push @schematic, [@row];
    push @valid, [(0) x $width];
}
push @schematic, [(".") x $width];  # add initial, final boundaries
unshift @schematic, [(".") x $width];
push @valid, [(0) x $width];
unshift @valid, [(0) x $width];
for my $i(1..@schematic-2){
    for my $j(1..$width-2){
	next unless $schematic[$i][$j]=~/$symbol/;
	for my $k(-1,0,1){     # validate neighbors of symbols
	    for my $l(-1,0,1){
		$valid[$i+$k][$j+$l]=1;
	    }
	}
    }
}
my $total=0;
for my $i(1..@schematic-2){
    my @row=@{$schematic[$i]};
    my @valid_row=@{$valid[$i]};
    my $number=0;
    my $valid=0;
    for my $j(1..$width-2){
	$valid||=$valid_row[$j], $number=10*$number+$row[$j], next if $row[$j]=~/\d/;
	$total+=$number if $valid;
	$number=0;
	$valid=0
    }
    $total+=$number if $valid;
    $number=0;
    $valid=0;
}
say $total;
#+end_src
*** Task b
Index all part numbers, i.e., strings of digits, by pushing them into
an array. For each gear, identify the part indices of the neighboring
parts. If there are exactly two, multiply them and accumulate the product.

#+begin_src perl :tangle 3b.pl :shebang #!/usr/bin/env perl
use v5.36;
my $gear=qr(\*);
my @schematic;
my @parts;
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    my $number;
    for(@row){
	if(/\d/){
	    $number//=0;
	    $number=10*$number+$_;
	    $_=@parts; # part index
	}else{
	    push @parts, $number if defined $number;
	    undef $number;
	}
    }
    push @schematic, [@row];
}
push @schematic, [(".") x @{$schematic[0]}];  # add initial, final boundaries
unshift @schematic, [(".") x @{$schematic[0]}];
my $total=0;
for my $i(1..@schematic-2){
    for my $j(1..$width-1){
	next unless $schematic[$i][$j]=~/$gear/;
	my %neighbors;
	for my $k(-1,0,1){
	    for my $l(-1,0,1){
		$neighbors{$schematic[$i+$k][$j+$l]}=1 if $schematic[$i+$k][$j+$l]=~/\d/;
	    }
	}
	my @neighbors=keys %neighbors;
	next unless @neighbors==2; # exactly two neighbors
	$total+=$parts[$neighbors[0]]*$parts[$neighbors[1]];
    }
}
say $total;
#+end_src
** Day 4
https://adventofcode.com/2023/day/4
*** Task a
I use a regular expression to throw away the card numbers and separate
the winning from the card numbers. I split those numbers on space. I
make a hash of winning numbers to check against the card numbers and
find how many matches m I get. If m==0, the score of that card is 0,
otherwise, it is 2^{m-1}.

#+begin_src perl :tangle 4a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $total=0;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    my $score=0;
    $score=1<<($matches-1) if $matches;
    $total += $score;
}
say $total;
#+end_src

*** Task b
I use the previous task to obtain how many numbers match the winning
numbers of each card and save that in an array. I start with one card
each. For each card number I keep an array of how many cards I have
and add that many cards to the number of following cards, according to
the score. I guess the code is clearer than this description.
#+begin_src perl :tangle 4b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(sum0);
my @scores;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    push @scores, $matches;
}
my @cards=(1) x @scores;
for(0..@scores-1){
    my $multiplier=$cards[$_];
    $cards[$_] += $multiplier for ($_+1..$_+$scores[$_]);
}
my $cards=sum0 @cards;
say $cards;
#+end_src

** Day 5
https://adventofcode.com/2023/day/5
*** Task a
#+begin_src perl :tangle 5a.pl :shebang #!/usr/bin/env perl
use v5.38;
use experimental 'class';
class Range {
    field $start_source :param;
    field $start_destination :param;
    field $length :param;
    method start_source {$start_source};
    method start_destination {$start_destination};
    method length {$length};
    method end_source {$start_source+$length-1};
    method end_destination {$start_destination+$length-1};
    method in_range($s){$s>=$start_source && $s < $start_source+$length};
    method destination($s){
	return $s-$start_source+$start_destination if $self->in_range($s);
	return $s;
    }
}
class Map {
    use List::Util qw(first);
    field $source :param;
    field $destination :param;
    field %ranges;
    field $ordered=0;
    field @ordered;
    method source {$source};
    method destination {$destination};
    method ranges {values %ranges};
    method add_range($range) {$ordered=0; $ranges{$range->start_source}=$range};
    method sort_range {$ordered=1; @ordered=sort {$b <=> $a} keys %ranges};
    method map($s){
	$self->sort_range unless $ordered;
	my $r=first {$_<=$s} @ordered; # dumb search
	return $s unless defined $r;
	my $range=$ranges{$r};
	$range->destination($s);
    }
}
sub read_map(){
    return if eof;
    while(<>){last unless /^$/;} # skip blank
    return if eof;
    die "Wrong name" unless /^\s*(\w+)-to-(\w+)\s+map:/i;
    my ($source, $destination)=($1,$2);
    my $map=Map->new(source=>$source, destination=>$destination);
    while(<>){
	last if /^$/;
	my ($sd, $ss, $l)=split " ";
	my $range=Range->new(start_source=>$ss, start_destination=>$sd, length=> $l);
	$map->add_range($range);
    }
    return $map;
}
chomp(my $line=<>);
die "Expected seeds" unless $line=~s/^\s*seeds:\s*//i;
my @seeds=split " ", $line;
my %maps;
while(my $map=read_map()){
    $maps{$map->source}=$map;
}
my $location;
my $desired="location";
foreach my $seed(@seeds){
    my $from="seed";
    my $number=$seed;
    while(1){
	my $map=$maps{$from};
	my $to=$map->destination;
	$number=$map->map($number);
	last if $to eq "location";
	$from=$to;
    }
    $location//=$number;
    $location=$number if $number<$location;
}
say $location;
#+end_src
*** Task b
My first attempt was to minimize the location for all seeds, but it
took several hours without finishing. Instead of checking individual seeds, I can
check seed ranges. I use a divide and conquer strategy. If the given
range in the source may be mapped to a single range in the
destination, I push into a queue the destination and the new
range. Otherwise, I cut it in half and retry each half for the same
source. The code follows, but it can be cleaned up. For the first time
I used the new ~class~ feature.


#+begin_src perl :tangle 5b.pl :shebang #!/usr/bin/env perl
use v5.38;
use experimental qw(class for_list);
use POSIX qw(floor);
class Range {
    field $start_source :param;
    field $start_destination :param;
    field $length :param;
    method start_source {$start_source};
    method start_destination {$start_destination};
    method length {$length};
    method end_source {$start_source+$length-1};
    method end_destination {$start_destination+$length-1};
    method in_range($s){$s>=$start_source && $s < $start_source+$length};
    method destination($s){
	return $s-$start_source+$start_destination if $self->in_range($s);
	return $s;
    }
}
class Map {
    use List::Util qw(first);
    field $source :param;
    field $destination :param;
    field %ranges;
    field $ordered=0;
    field @ordered;
    method source {$source};
    method destination {$destination};
    method ranges {values %ranges};
    method add_range($range) {$ordered=0; $ranges{$range->start_source}=$range};
    method sort_range {$ordered=1; @ordered=sort {$b <=> $a} keys %ranges};
    method range_before($s){
	$self->sort_range unless $ordered;
	my $r=first {$_<=$s} @ordered; # dumb search
	return unless defined $r;
	return $ranges{$r};
    }
    method range_after($s){
	$self->sort_range unless $ordered;
	my $r=first {$_>$s} reverse @ordered;
	return unless $r;
	return $ranges{$r};
    }
    method destination_of($s){
	my $range=$self->range_before($s);
	$self->sort_range unless $ordered;
	return $s unless defined $range;
	$range->destination($s);
    }
}
sub read_map(){
    return if eof;
    while(<>){last unless /^$/;} # skip blank
    return if eof;
    die "Wrong name" unless /^\s*(\w+)-to-(\w+)\s+map:/i;
    my ($source, $destination)=($1,$2);
    my $map=Map->new(source=>$source, destination=>$destination);
    while(<>){
	last if /^$/;
	my ($sd, $ss, $l)=split " ";
	my $range=Range->new(start_source=>$ss, start_destination=>$sd, length=> $l);
	$map->add_range($range);
    }
    return $map;
}
chomp(my $line=<>);
die "Expected seeds" unless $line=~s/^\s*seeds:\s*//i;
my @seeds=split " ", $line;
my %maps;
while(my $map=read_map()){
    $maps{$map->source}=$map;
}
my $best_location;
my $desired="location";
my @pending;
foreach my ($seed, $seed_nvals)(@seeds){
    push @pending, ["seed", $seed, $seed_nvals];
    while(@pending){
	my $source_range=shift @pending;
	my ($source, $initial, $nvals)=@$source_range;
	my $final=$initial+$nvals-1;
	if($source eq $desired){
	    $best_location //= $initial;
	    $best_location=$initial if $initial < $best_location;
	    next;
	}
	my $map=$maps{$source};
	my $destination=$map->destination;
	my $range0=$map->range_before($initial);
	my $range1=$map->range_after($initial);
	undef $range0 if defined $range0 and $range0->end_source < $initial;
	my $half=floor $nvals/2;
	if(not defined $range0){
	    push(@pending, [$destination, $initial, $nvals]), next if not defined $range1;
	    push(@pending, [$destination, $initial, $nvals]), next
		if $final < $range1->start_source;
	    push(@pending, [$source, $initial, $half]);
	    push(@pending, [$source, $initial+$half, $nvals-$half]);
	    next;
	}
	push(@pending, [$destination, $map->destination_of($initial), $nvals]), next
	    if $final <= $range0->end_source;
	push(@pending, [$source, $initial, $half]);
	push(@pending, [$source, $initial+$half, $nvals-$half]);
    }
}
say $best_location;
#+end_src
** Day 6
https://adventofcode.com/2023/day/6
*** Task a
The distance d travelled is equal to the speed v times the available
time (t-v), where t is the total time and the held time is equal to
the speed. Thus, d=vt-v^2. I need d>d_0. Thus, I solve the quadratic
equation v^2-vt-d_0 = 0, and the held time is bounded by the two
solutions.

#+begin_src perl :tangle 6a.pl :shebang #!/usr/bin/env perl
use v5.36;
use POSIX qw(floor ceil);
chomp(my $times=<>);
die "Bad times" unless $times=~s/^\s*Time:\s*(.*)\s*$/$1/i;
my @times=split " ", $times;
chomp(my $distances=<>);
die "Bad distances" unless $distances=~s/^\s*Distance:\s*(.*)\s*/$1/i;
my @distances=split " ", $distances;
die "Wrong dimensions" unless @times==@distances;
my $total=1;
for(0..@times-1){
    my $t=$times[$_];
    my $x=$distances[$_];
    my $s=sqrt($t**2-4*$x);
    my $v0=ceil(($t-$s)/2);
    my $v1=floor(($t+$s)/2);
    my $ways=$v1-$v0+1;
    $ways-=2 if $s==floor($s);
    $total*=$ways;
}
say $total;

#+end_src

*** Task b

#+begin_src perl :tangle 6b.pl :shebang #!/usr/bin/env perl
use v5.36;
use POSIX qw(floor ceil);
chomp(my $t=<>);
die "Bad times" unless $t=~s/^\s*Time:\s*(.*)\s*$/$1/i;
chomp(my $x=<>);
die "Bad distances" unless $x=~s/^\s*Distance:\s*(.*)\s*/$1/i;
s/\s+//g for ($t, $x);
my $s=sqrt($t**2-4*$x);
my $v0=ceil(($t-$s)/2);
my $v1=floor(($t+$s)/2);
my $ways=$v1-$v0+1;
$ways-=2 if $s==floor($s);
say $ways;

#+end_src

** Day 7
https://adventofcode.com/2023/day/7
*** Task a
I make an ranked array of card values and of possible games, each
characterized by an array with ordered card patterns, i.e. [5] (five
of a kind) [4,1] (four of a kind), [3,2] (full house), etc. I build an
array of hands. Each and is characterized by its string representation
and the bid, taken from the input data, the score of the hand
according to their type and an array of the values of each card. Then,
I rank all games by sorting on their scores and if necessary on their
values.

#+begin_src perl :tangle 7a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0 first);
my @cards=qw(2 3 4 5 6 7 8 9 T J Q K A);
my %value_cards;
$value_cards{$cards[$_]}=sprintf "%02d", $_ for 0..@cards-1;
my @games=(11111, 2111, 221, 311, 32, 41, 5);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=card_numbers($hand);
    my $values=join "", map {$value_cards{$_}} split "", $hand;
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {$a->[2] cmp $b->[2] || $a->[3] cmp $b->[3]} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    return join "", sort {$b<=>$a} values %m;
}
#+end_src

*** Task b
The solution is almost identical, but if a hand has jokers besides
other cards, the number of jokers is added to the card that is
repeated the most before scoring.

#+begin_src perl :tangle 7b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0 first);
my @cards=qw(J 2 3 4 5 6 7 8 9 T Q K A);
my %value_cards;
$value_cards{$cards[$_]}=sprintf "%02d", $_ for 0..@cards-1;
my @games=(11111, 2111, 221, 311, 32, 41, 5);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=card_numbers($hand);
    my $values=join "", map {$value_cards{$_}} split "", $hand;
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {$a->[2] cmp $b->[2] || $a->[3] cmp $b->[3]} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    my @sorted=sort {$m{$b}<=>$m{$a}} keys %m;
    for(0..@sorted-1){
	if($sorted[$_] eq "J"){
	    my $add=$m{"J"};
	    if(@sorted>1){ # if other cards
		splice @sorted, $_, 1; # add J to others
		$m{$sorted[0]} += $add;
	    }
	    last;
	}
    }
    return join "", map {$m{$_}} @sorted;
}

#+end_src

** Day 8
https://adventofcode.com/2023/day/8
*** Task a

#+begin_src perl :tangle 8a.pl :shebang #!/usr/bin/env perl
use v5.36;
chomp(my $instructions=<>);
my @instructions=split "", $instructions;
sub next_move() {
    my $move=shift @instructions;
    push @instructions, $move;
    return $move;
}
my %node;
chomp(my $space=<>);
die "Bad format" unless $space=~/^\s*$/;
while(<>){
    /(\w{3})\s*=\s*\((\w{3})\,\s*(\w{3})\s*\)$/
    or die "Bad format";
    my ($f, $l, $r)=($1, $2, $3);
    die if defined $node{$f};
    $node{$f}{L}=$l;
    $node{$f}{R}=$r;
}
die "Missing start" unless defined $node{AAA};
my $current="AAA";
my $steps=0;
while($current ne "ZZZ"){
    ++$steps;
    die "Missing node" unless defined $node{$current};
    $current=$node{$current}{next_move()}
}
say $steps;
#+end_src

*** Task b
The solution is almost identical, but if a hand has jokers besides
other cards, the number of jokers is added to the card that is
repeated the most before scoring. I can step all current nodes a step
at a time until I finish, as in the following code:

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all);
chomp(my $instructions=<>);
my @instructions=split "", $instructions;
sub next_move() {
    my $move=shift @instructions;
    push @instructions, $move;
    return $move;
}
my %node;
chomp(my $space=<>);
die "Bad format" unless $space=~/^\s*$/;
my @current;
while(<>){
    /(\w{3})\s*=\s*\((\w{3})\,\s*(\w{3})\s*\)$/
    or die "Bad format";
    my ($f, $l, $r)=($1, $2, $3);
    die if defined $node{$f};
    $node{$f}{L}=$l;
    $node{$f}{R}=$r;
    push @current, $f if $f=~/A$/;
    $node{$f}{end}=1 if $f=~/Z$/;
}
die "Missing start" unless @current;
my $steps=0;
while(not all {$node{$_}{end}} @current){
    ++$steps;
    my $move=next_move;
    my @next;
    for(@current){
	die "Missing node" unless defined $node{$_};
	push @next, $node{$_}{$move}
    }
    @current=@next;
}
say $steps;
#+end_src

I ran it and it seems to take forever.

I tried several alternatives, trying to find the lengths that take
from a possible ending location to another ending location, so that I
can advance by large steps. But then I would advance by different
number of elementary steps and I would have to synchronize the
different advancing paths. Then I got an inspiration. Since the
general case seem so difficult, maybe the task is easier than the
general case. Maybe the paths are cyclical and from an ending location
they loop back to the starting location. I checked that they do. Then
the solution becomes trivial. I just have to find the lowest common
multiple of all the cycles!

#+begin_src perl :tangle 8b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all);
use Math::Prime::Util qw(lcm);
chomp(my $instructions=<>);
my @instructions=split "", $instructions;
my $num_instructions=@instructions;
my %node;
chomp(my $space=<>);
die "Bad format" unless $space=~/^\s*$/;
my @start;
my %end;
while(<>){
    /(\w{3})\s*=\s*\((\w{3})\,\s*(\w{3})\s*\)$/
    or die "Bad format";
    my ($f, $l, $r)=($1, $2, $3);
    die if defined $node{$f};
    $node{$f}{L}=$l;
    $node{$f}{R}=$r;
    push @start, $f if $f=~/A$/;
    $end{$f}=1  if $f=~/Z$/;
}
die "Missing start" unless @start;
# Find cycle lengths
my @cycles;
for (@start){
    my $current=$_;
    my $t=0;
    $current=$node{$current}{instruction($t++)} while(!$end{$current});
    push @cycles, $t;
}
my $length= lcm(@cycles);
say $length;

sub instruction($step){
    $instructions[$step%$num_instructions];
}
#+end_src

** Day 9
https://adventofcode.com/2023/day/9
*** Task a
To find an extrapolated value I use a recursive procedure.
I use the Perl Data Language which has operators to slice arrays,
operate on all elements of an array, etc. The result is 0 if the array
is made of zeroes. The result is the last element plus the result of
extrapolating the array of first differences. The result is a very
short program.

#+begin_src perl :tangle 9a.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
my $total=0;
while(<>){
    chomp;
    $total += extrapolate(pdl($_));
}
say $total;

sub extrapolate($v){
    return 0 if ($v==0)->all;
    return $v->at(-1)+extrapolate($v(1:-1)-$v(0:-2));
}
#+end_src

It actually fits a one-liner
#+begin_src bash :results output
perl -n -MPDL -MPDL::NiceSlice -E '
sub e($v){return 0 if ($v==0)->all; $v(-1)+e($v(1:-1)-$v(0:-2))}chomp; $t+=e(pdl($_))}{say $t->at(-1)
' 9.txt
#+end_src

Results:
: 1987402313
*** Task b
I believe the code is almost identical. I just subtract from the
leftmost instead of adding to the rightmost.
#+begin_src perl :tangle 9b.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
my $total=0;
while(<>){
    chomp;
    $total += extrapolate(pdl($_));
}
say $total;

sub extrapolate($v){
    return 0 if ($v==0)->all;
    return $v->at(0)-extrapolate($v(1:-1)-$v(0:-2));
}
#+end_src
This also fits a oneliner
#+begin_src bash :results output
perl -n -MPDL -MPDL::NiceSlice -E '
sub e($v){return 0 if ($v==0)->all;$v((0))- e($v(1:-1)-$v(0:-2))}chomp;$t+=e(pdl($_))}{say $t->at(0)
' 9.txt
#+end_src

Results:
: 900
** Day 10
https://adventofcode.com/2023/day/10
*** Task a
I make a hash to map directions to coordinate increments. For each
type of tile, I make a string that describes the in and out directions
and convert it into a map. I find the first tile, any direction which
lands on a valid tile (which can be reached moving in that direction,
i.e., which has that direction as a key in the map. Then I simply
follow directions until I come back to the start. The distance to the
farthest point is half the total length of the path.

#+begin_src perl :tangle 10a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::MoreUtils qw(firstidx);
my %dirs=(R=>[1,0], U=>[0,-1], L=>[-1,0], D=>[0,1]);
my @tiles=qw(JRUDL -RRLL 7RDUL |UUDD FURLD LLUDR s .);
my %map=map {my @t=split ""; @t==5?($t[0]=>{$t[1]=>$t[2], $t[3]=>$t[4]}):()} @tiles;
my @sketch;
my $row=0;
my $current_coords;
while(<>){
    chomp;
    my @row=split "";
    push @sketch, [@row];
    my $col = firstidx {$_ eq "S"} @row;
    $current_coords=[$col,$row] if $col >= 0;
    ++$row;
}
die "No initial tile" unless defined $current_coords;
my $step;
my $tile;
# find and take first step
for(qw(R U L D)){
    my $dir=$dirs{$_};
    my $next_coords = add($current_coords, $dir);
    $tile=tile($next_coords);
    my $next_step=$map{$tile}{$_};
    $current_coords=$next_coords, $step=$_, last if defined $next_step;
}
my $length=1;
# Notice step is out of phase with coords
while($tile ne "S"){
    $step=$map{$tile}{$step};
    die "Shouldn't happen" unless defined $step;
    my $dir=$dirs{$step};
    $current_coords = add($current_coords, $dir);
    $tile=tile($current_coords);
    ++$length;
}
say $length/2;


sub tile($p){
    my @p=@$p;
    return $sketch[$p[1]][$p[0]];
}
sub add($p, $q){
    return [map {$p->[$_]+ $q->[$_]}(0,1)];
}

#+end_src

*** Task b

For the second task I guess I can use the even odd rule to identify
sites within the loop. Tiles not in the path are counted if I can
reach them crossing the path an odd number of times. The problem is to
identify the crossings. Crossings are path fragments that match /|/,
/F-*J/ or /L-*7/.

#+begin_src perl :tangle 10b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::MoreUtils qw(firstidx);
my %dirs=(R=>[1,0], U=>[0,-1], L=>[-1,0], D=>[0,1]);
my @tiles=qw(JRUDL -RRLL 7RDUL |UUDD FURLD LLUDR S .);
my %map=map {my @t=split ""; @t==5?($t[0]=>{$t[1]=>$t[2], $t[3]=>$t[4]}):()} @tiles;
my @sketch;
my $row=0;
my $current_coords;
while(<>){
    chomp;
    my @row=split "";
    push @sketch, [@row];
    my $col = firstidx {$_ eq "S"} @row;
    $current_coords=[$col,$row] if $col >= 0;
    ++$row;
}
die "No initial tile" unless defined $current_coords;
my %in_path;
my $step;
my $tile;
# find and take first step
for(qw(U R D L)){
    my $dir=$dirs{$_};
    my $next_coords = add($current_coords, $dir);
    $tile=tile($next_coords);
    my $next_step=$map{$tile}{$_};
    if(defined $next_step){
	$in_path{"@$current_coords"}=1;
	$current_coords=$next_coords;
	$step=$_;
	last;
    }
}
my $first_step=$step;
# Notice step is out of phase, behind coords and tile
while($tile ne "S"){
    $step=$map{$tile}{$step};
    die "Shouldn't happen" unless defined $step;
    $in_path{"@$current_coords"}=1;
    my $dir=$dirs{$step};
    $current_coords = add($current_coords, $dir);
    $tile=tile($current_coords);
}
my $last_step=$step;
my ($start_x, $start_y)=@$current_coords;
for(keys %map){ # replace starting symbol by correct tile
    next unless defined $map{$_} && defined $map{$_}{$last_step};
    $sketch[$start_y][$start_x]=$_, last if $map{$_}{$last_step} eq $first_step;
}

my $height=@sketch;
my $width=$sketch[0]->@*;
my $count=0;
for my $y (0..$height-1){
    my $odd=0;
    my $enter="";
    my $local_count=0;
    for my $x (0..$width-1){
	my $tile=tile([$x,$y]);
	if($in_path{"$x $y"}){
	    $enter=$tile if $tile=~/[FL]/;
	    $odd=!$odd
		if $tile eq "|"
		or $enter eq "F" and $tile eq "J"
		or $enter eq "L" and $tile eq "7";
	    $enter="" if $tile=~/[J7]/;
	    $count += $local_count;
	    $local_count=0;
	}else{
	    ++$local_count if $odd;
	}
    }
}

say $count;

sub tile($p){
    my @p=@$p;
    return $sketch[$p[1]][$p[0]];
}
sub add($p, $q){
    return [map {$p->[$_]+ $q->[$_]}(0,1)];
}

#+end_src

** Day 11
https://adventofcode.com/2023/day/11
*** Task a
I read the map of the universe into a pdl matrix after changing vacuum
into zeroes and galaxies into ones. For each null row I add
another. Then I transpose the matrix and for each null row (transposed
column) I add another, to get the expanded universe. Finally, for all
pairs of galaxies I add the absolute values of the difference of their
coordinates.

#+begin_src perl :tangle 11a.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
use Algorithm::Combinatorics qw(combinations);
my @universe;
while(<>){
    chomp;
    s/\./0/g;
    s/\#/1/g;
    my $r=pdl split "";
    push @universe, $r;
}
my $universe=pdl(@universe);
my $zero_row=$universe(:,(0))->zeroes;
my @universe_yexpanded;
for(@universe){
    push @universe_yexpanded, $_;
    push @universe_yexpanded, $_ if ($_==0)->all;
}
my $universe_yexpanded=pdl(@universe_yexpanded);
my @universe_xyexpanded;
for($universe_yexpanded->transpose->dog){
    push @universe_xyexpanded, $_;
    push @universe_xyexpanded, $_ if ($_==0)->all;
}
my $universe_expanded=pdl(@universe_xyexpanded)->transpose;
my $galaxies=$universe_expanded->whichND;
my $galaxy_pairs=combinations([$galaxies->dog], 2);
my $sum=0;
while(my $g=$galaxy_pairs->next){
    my $r=pdl($g);
    $sum+=($r(:,(1))-$r(:,(0)))->abs->sumover;
}
say $sum;
#+end_src

*** Task b
For this problem it would make no sense to include additional rows and
columns for the expanded space. What I may do is assign coordinates to
all galaxies and then increment their x or y coordinates if the space
is horizontally or vertically expanded before them. Finally, I simply
subtract the resulting coordinates, take their absolute values and add.

#+begin_src perl :tangle 11b.pl :shebang #!/usr/bin/env perl
use v5.36;
use v5.36;
my $factor=1000000; # expansion factor
use PDL;
use PDL::NiceSlice;
use Algorithm::Combinatorics qw(combinations);
my @universe;
while(<>){
    chomp;
    s/\./0/g;
    s/\#/1/g;
    my $r=pdl split "";
    push @universe, $r;
}
my $universe=pdl(@universe);
my $galaxies=$universe->whichND; # get coordinates of galaxies
my $expansion_x=(!$universe->transpose->orover)->which;
my $expansion_y=(!$universe->orover)->which;
my $xcoords=sequence($universe->dim(0));
for($expansion_x->dog){
    $xcoords($_:-1)+=$factor-1;
}
my $ycoords=sequence($universe->dim(1));
for($expansion_y->dog){
    $ycoords($_:-1)+=$factor-1;
}
my $galaxy_pairs=combinations([$galaxies->dog], 2);
my $sum=0;
while(my $g=$galaxy_pairs->next){
    my($r0, $r1)=map{pdl($_)}@$g;
    for($r0, $r1){
	$_(0).=$xcoords($_((0)));
	$_(1).=$ycoords($_((1)));
    }
    $sum+=($r1-$r0)->abs->sumover;
}
say $sum;
#+end_src

** Day 12
https://adventofcode.com/2023/day/12
*** Task a
After a long time trying different solutions I read a comment by Adam
Crussel mentioning he saw a solution in Sed. I didn't look at that
solution, but tried my own with a regular expression. It was really
simple using the possibility of executing code (incrementing a
counter) after matching and then forcing failure so that the regular
expression tries the next match. It took only a few minutes to read
about code execution within regular expressions and forcing failure. I
build the regular expression for each line

#+begin_src perl :tangle 12a.pl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
while(<>){
    chomp;
    my ($condition,$duplicate)=split " ";
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
}
say $count;
#+end_src

This is the same, but compressed to a two-liner.
#+begin_src bash :results output
time perl -Mre=eval -E '
$c=0;while(<>){chomp;($s,$d)=split " ";@n=split ",", $d;$re="^[.?]*" . join("[.?]+",
map {"[?#]{$_}"} @n) . "[?.]*\$(?{++\$c})(*FAIL)";$s=~/$re/;}say $c;
' 12.txt
#+end_src

Results:
: 7653


*** Task b
The second task seems relatively trivial. I make the indicated
replacements and run the code of the previous task.
#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
while(<>){
    chomp;
    my ($condition,$duplicate)=split " ";
    $condition=join "?", (("$condition") x 5); # unfold
    $duplicate=join ",", (("$duplicate") x 5);
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
}
say $count;
#+end_src


However, this takes forever. A simplistic solution would be to solve the first
problem and raise each row to the fifth power. It doesn't work as the
joining springs may be failed. Another alternative is to separate the cases
where all the joining springs work (the fifth power of the previous
task), where all work except one (the fourth power of the  previous
task times the result for two records joined by a failing spring)
multiplied by the four positions for the failed joining spring,
plus... Not sure if it will be fast enough nor if it's correct. I am
assuming that when two records are joind by a working spring, there
are no solutions that cross records.

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
my $total;
while(<>){
    chomp;
    say $.;
    my ($condition,$duplicate)=split " ";
    my ($c1, $c2, $c3, $c4, $c5)=map {
	solve((join "#", (("$condition") x $_)),(join ",", (("$duplicate") x $_)));
    } 1..5;
    my $subtotal=$c1**5 + 4*$c2*$c1**3 + 3*$c2**2*$c1 + 3*$c3*$c1**2 + 2*$c3*$c2 + 2*$c4*$c1 + $c5;
    $total += $subtotal;
}
say $total;

sub solve($condition, $duplicate){
    my $count=0;
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
    return $count;
}

#+end_src

This didn't work either. I try now the first approach, but simplifying
the pattern first, using single '.' as separator. I'm not optimistic.

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
while(<>){
    chomp;
    my ($condition,$duplicate)=split " ";
    $condition=join "?", (("$condition") x 5); # unfold
    $condition.="."; # add guard
    $condition=~s/\.+/./; # shorten separators
    $duplicate=join ",", (("$duplicate") x 5);
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
    say $.;
}
say $count;
#+end_src

No, it didn't work.

I guess a solution might be to make a regular expression to match the
first series of damaged springs. On success, recurse for the rest of the
series and the rest of the records. Then, if the matched string starts
with a ?, eliminate the starting character and search again for more
matches. I also memoize the recursive calls to gain speed.

#+begin_src perl :shebang #!/usr/bin/env perl :tangle 12b.pl
use v5.36;
use Memoize;
memoize("howmany");
my $total=0;
my $copies=5;
while(<>){
    chomp;
    my ($record,$duplicate)=split " ";
    $record=join "?", (("$record") x $copies); # unfold
    $record.="."; # add guard
    $record=~s/\.+/./; # shorten separators
    $duplicate=join ",", (("$duplicate") x $copies);
    my @ndamaged=split ",", $duplicate;
    my $count=howmany($record, @ndamaged);
    $total += $count;
}
say $total;

sub howmany($record, @ndamaged){
    my $count=0;
    return $record=~/#/?0:1 unless @ndamaged;
    my $damaged=shift @ndamaged;
    while($record && $record=~s/^[^#]*?([?#]{$damaged}[^#])//){
	my $matched=$1;
	my $found = howmany($record, @ndamaged);
	$count += $found;
	last if $matched=~/^#/;
	$matched=~s/^.//; #shorten next record
	$record=$matched.$record;
    }
    return $count;
}

#+end_src

** Day 13
https://adventofcode.com/2023/day/13
*** Task a

#+begin_src perl :tangle 13a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all min);
local $/=""; # paragraph at a time
my $total=0;
while(<>){
    my @rows=split /^/;
    pop @rows if $rows[-1]=~/^$/; # remove empty line
    chomp for @rows;
    my $width=length $rows[0];
    my $height=@rows;
    my @cols;
    for (0..@rows-1){
	my @row=split "", $rows[$_];
	$cols[$_].=$row[$_] for 0..$width-1;
    }
    my @horizontal=search_mirror(@rows);
    my @vertical=search_mirror(@cols);
    $total+=($_+1)*100 for @horizontal;
    $total+=$_+1 for @vertical;
}
say $total;

sub search_mirror(@arr){ # search mirror plane
    my $N=@arr;
    my @c;
    for my $c(0..$N-2){
	my $m=min($c, $N-2-$c);
	push @c, $c if all {$arr[$c-$_] eq $arr[$c+1+$_]} (0..$m);
    }
    return @c;
}

#+end_src


*** Task b
According to the statement, there is exactly one horizontal or
vertical mirror that produces a perfect image except at one
position. The problem is to locate it. I simply count how many errors
would be present for all potential mirrors. If there is only one
error, that is the mirror. I need not correct the error, as I only
need the mirror's number.

#+begin_src perl :tangle 13b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(min);
local $/=""; # paragraph at a time
my %exchange=("."=>"#", "#"=>".");
my $total=0;
while(<>){
    my @rows=split /^/;
    pop @rows if $rows[-1]=~/^$/; # remove empty line
    chomp for @rows;
    my $width=length $rows[0];
    my $height=@rows;
    my @sketch;
    push @sketch, [split "", $_] for @rows;
    my $h=analyze(@sketch);
    my $v=analyze(transpose(@sketch));
    $total+=100*$h+$v;
}
say $total;

sub analyze(@arr){ # search mirror planes
    my $height=@arr;
    my $width=@{$arr[0]};
    for my $r(0..$height-2){ # for each possible mirror
	my $errs; # number of errors
	my $m=min($r, $height-2-$r);
	for(0..$m){ # for each object-image pair
	    for my $c(0..$width-1){
		my $diff=$arr[$r-$_][$c] ne $arr[$r+1+$_][$c];
		$errs+=$diff;
	    }
	}
	return $r+1 if($errs==1); #assume only one mirror with exactly one smudge
    }
    return 0;
}

sub transpose(@arr){
    my @res;
    return @res unless @arr;
    my $height=@arr;
    my $width=@{$arr[0]} if $height;
    for my $i(0..$height-1){
	for my $j(0..$width-1){
	    $res[$j][$i]=$arr[$i][$j];
	}
    }
    return @res;
}

#+end_src
