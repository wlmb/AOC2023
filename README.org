* Advent of code
Trying my luck for the first time with the [[https://adventofcode.com/2023/about][Advent of Code]] 2023.
** Day 1
https://adventofcode.com/2023/day/1
*** Task a
Use non-greedy regular expressions to get the first and last digits of
each row

#+begin_src perl :tangle 1a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
while(<>){
    /^.*?(\d)/ and my $f=$1 or die;
    /.*(\d).*?$/ and my $l=$1 or die;
    $tot += "$f$l";
}
say $tot;
#+end_src
*** Task b
Make a regular expression to identify digits and digit names.
#+begin_src perl :tangle 1b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
my @digits=qw(one two three four five six seven eight nine);
my $i=1;
my %digit;
$digit{$_}=$i++ for @digits;
$digit{$_}=$_ for 0..9;
my $digit=join "|", @digits, '\d';
my $first=qr"^.*?($digit)"i;
my $last=qr".*($digit).*?$"i;
while(<>){
    /$first/ and my $f=$1 or die;
    /$last/ and my $l=$1 or die;
    $tot += "$digit{$f}$digit{$l}";
}
say $tot;
#+end_src
** Day 2
https://adventofcode.com/2023/day/2
*** Task a
Use regular expressions to obtain game ids. Split to obtain the
subsets of cubes. Use a regular expression to obtain the number of
cubes of each color and check if there are enough cubes in the bag.
#+begin_src perl :tangle 2a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum possible game ids for 12 red cubes, 13 green cubes, and 14 blue cubes
use v5.36;
my %available=(red=>12, green=>13, blue=>14);
my $total=0;
while(<>){
    s/Game\s*(\d+):\s*// or die;
    my $id=$1;
    my $impossible=0;
    SUBSET: for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    $impossible=1,last SUBSET if $quantity>$available{$color};
	}
    }
    $total += $id unless $impossible;
}
say $total;
#+end_src
*** Task b
Use a regular expression and split to obtain the subsets. Adjust the
minimum number of cubes necessary to fullfill all samples, multiply
them and add.

#+begin_src perl :tangle 2b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum minimum powers of games
use v5.36;
use List::Util qw(product);
my $total=0;
while(<>){
    s/Game\s*\d+:\s*// or die;
    my %minima=(red=>0, green=>0, blue=>0);
    for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    ($_<$quantity) && ($_=$quantity) for $minima{$color};
	}
    }
    my $product=product values %minima;
    $total += $product;
}
say $total;
#+end_src
** Day 3
https://adventofcode.com/2023/day/3
*** Task a
Read the schematics into an array. Add dots "." at the boundaries as
guards. For each symbol, mark as valid its nearest
neighbors. Accumulate all numbers, i.e., strings of digits, that
overlap a valid cell.

#+begin_src perl :tangle 3a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $symbol=qr([^\.\d]);
my @schematic;
my @valid; # valid sites
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    push @schematic, [@row];
    push @valid, [(0) x $width];
}
push @schematic, [(".") x $width];  # add initial, final boundaries
unshift @schematic, [(".") x $width];
push @valid, [(0) x $width];
unshift @valid, [(0) x $width];
for my $i(1..@schematic-2){
    for my $j(1..$width-2){
	next unless $schematic[$i][$j]=~/$symbol/;
	for my $k(-1,0,1){     # validate neighbors of symbols
	    for my $l(-1,0,1){
		$valid[$i+$k][$j+$l]=1;
	    }
	}
    }
}
my $total=0;
for my $i(1..@schematic-2){
    my @row=@{$schematic[$i]};
    my @valid_row=@{$valid[$i]};
    my $number=0;
    my $valid=0;
    for my $j(1..$width-2){
	$valid||=$valid_row[$j], $number=10*$number+$row[$j], next if $row[$j]=~/\d/;
	$total+=$number if $valid;
	$number=0;
	$valid=0
    }
    $total+=$number if $valid;
    $number=0;
    $valid=0;
}
say $total;
#+end_src
*** Task b
Index all part numbers, i.e., strings of digits, by pushing them into
an array. For each gear, identify the part indices of the neighboring
parts. If there are exactly two, multiply them and accumulate the product.

#+begin_src perl :tangle 3b.pl :shebang #!/usr/bin/env perl
use v5.36;
my $gear=qr(\*);
my @schematic;
my @parts;
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    my $number;
    for(@row){
	if(/\d/){
	    $number//=0;
	    $number=10*$number+$_;
	    $_=@parts; # part index
	}else{
	    push @parts, $number if defined $number;
	    undef $number;
	}
    }
    push @schematic, [@row];
}
push @schematic, [(".") x @{$schematic[0]}];  # add initial, final boundaries
unshift @schematic, [(".") x @{$schematic[0]}];
my $total=0;
for my $i(1..@schematic-2){
    for my $j(1..$width-1){
	next unless $schematic[$i][$j]=~/$gear/;
	my %neighbors;
	for my $k(-1,0,1){
	    for my $l(-1,0,1){
		$neighbors{$schematic[$i+$k][$j+$l]}=1 if $schematic[$i+$k][$j+$l]=~/\d/;
	    }
	}
	my @neighbors=keys %neighbors;
	next unless @neighbors==2; # exactly two neighbors
	$total+=$parts[$neighbors[0]]*$parts[$neighbors[1]];
    }
}
say $total;
#+end_src
** Day 4
https://adventofcode.com/2023/day/4
*** Task a
I use a regular expression to throw away the card numbers and separate
the winning from the card numbers. I split those numbers on space. I
make a hash of winning numbers to check against the card numbers and
find how many matches m I get. If m==0, the score of that card is 0,
otherwise, it is 2^{m-1}.

#+begin_src perl :tangle 4a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $total=0;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    my $score=0;
    $score=1<<($matches-1) if $matches;
    $total += $score;
}
say $total;
#+end_src

*** Task b
I use the previous task to obtain how many numbers match the winning
numbers of each card and save that in an array. I start with one card
each. For each card number I keep an array of how many cards I have
and add that many cards to the number of following cards, according to
the score. I guess the code is clearer than this description.
#+begin_src perl :tangle 4b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(sum0);
my @scores;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    push @scores, $matches;
}
my @cards=(1) x @scores;
for(0..@scores-1){
    my $multiplier=$cards[$_];
    $cards[$_] += $multiplier for ($_+1..$_+$scores[$_]);
}
my $cards=sum0 @cards;
say $cards;
#+end_src

** Day 5
https://adventofcode.com/2023/day/5
*** Task a
#+begin_src perl :tangle 5a.pl :shebang #!/usr/bin/env perl
use v5.38;
use experimental 'class';
class Range {
    field $start_source :param;
    field $start_destination :param;
    field $length :param;
    method start_source {$start_source};
    method start_destination {$start_destination};
    method length {$length};
    method end_source {$start_source+$length-1};
    method end_destination {$start_destination+$length-1};
    method in_range($s){$s>=$start_source && $s < $start_source+$length};
    method destination($s){
	return $s-$start_source+$start_destination if $self->in_range($s);
	return $s;
    }
}
class Map {
    use List::Util qw(first);
    field $source :param;
    field $destination :param;
    field %ranges;
    field $ordered=0;
    field @ordered;
    method source {$source};
    method destination {$destination};
    method ranges {values %ranges};
    method add_range($range) {$ordered=0; $ranges{$range->start_source}=$range};
    method sort_range {$ordered=1; @ordered=sort {$b <=> $a} keys %ranges};
    method map($s){
	$self->sort_range unless $ordered;
	my $r=first {$_<=$s} @ordered; # dumb search
	return $s unless defined $r;
	my $range=$ranges{$r};
	$range->destination($s);
    }
}
sub read_map(){
    return if eof;
    while(<>){last unless /^$/;} # skip blank
    return if eof;
    die "Wrong name" unless /^\s*(\w+)-to-(\w+)\s+map:/i;
    my ($source, $destination)=($1,$2);
    my $map=Map->new(source=>$source, destination=>$destination);
    while(<>){
	last if /^$/;
	my ($sd, $ss, $l)=split " ";
	my $range=Range->new(start_source=>$ss, start_destination=>$sd, length=> $l);
	$map->add_range($range);
    }
    return $map;
}
chomp(my $line=<>);
die "Expected seeds" unless $line=~s/^\s*seeds:\s*//i;
my @seeds=split " ", $line;
my %maps;
while(my $map=read_map()){
    $maps{$map->source}=$map;
}
my $location;
my $desired="location";
foreach my $seed(@seeds){
    my $from="seed";
    my $number=$seed;
    while(1){
	my $map=$maps{$from};
	my $to=$map->destination;
	$number=$map->map($number);
	last if $to eq "location";
	$from=$to;
    }
    $location//=$number;
    $location=$number if $number<$location;
}
say $location;
#+end_src
*** Task b
My first attempt was to minimize the location for all seeds, but it
took several hours without finishing. Instead of checking individual seeds, I can
check seed ranges. I use a divide and conquer strategy. If the given
range in the source may be mapped to a single range in the
destination, I push into a queue the destination and the new
range. Otherwise, I cut it in half and retry each half for the same
source. The code follows, but it can be cleaned up. For the first time
I used the new ~class~ feature.


#+begin_src perl :tangle 5b.pl :shebang #!/usr/bin/env perl
use v5.38;
use experimental qw(class for_list);
use POSIX qw(floor);
class Range {
    field $start_source :param;
    field $start_destination :param;
    field $length :param;
    method start_source {$start_source};
    method start_destination {$start_destination};
    method length {$length};
    method end_source {$start_source+$length-1};
    method end_destination {$start_destination+$length-1};
    method in_range($s){$s>=$start_source && $s < $start_source+$length};
    method destination($s){
	return $s-$start_source+$start_destination if $self->in_range($s);
	return $s;
    }
}
class Map {
    use List::Util qw(first);
    field $source :param;
    field $destination :param;
    field %ranges;
    field $ordered=0;
    field @ordered;
    method source {$source};
    method destination {$destination};
    method ranges {values %ranges};
    method add_range($range) {$ordered=0; $ranges{$range->start_source}=$range};
    method sort_range {$ordered=1; @ordered=sort {$b <=> $a} keys %ranges};
    method range_before($s){
	$self->sort_range unless $ordered;
	my $r=first {$_<=$s} @ordered; # dumb search
	return unless defined $r;
	return $ranges{$r};
    }
    method range_after($s){
	$self->sort_range unless $ordered;
	my $r=first {$_>$s} reverse @ordered;
	return unless $r;
	return $ranges{$r};
    }
    method destination_of($s){
	my $range=$self->range_before($s);
	$self->sort_range unless $ordered;
	return $s unless defined $range;
	$range->destination($s);
    }
}
sub read_map(){
    return if eof;
    while(<>){last unless /^$/;} # skip blank
    return if eof;
    die "Wrong name" unless /^\s*(\w+)-to-(\w+)\s+map:/i;
    my ($source, $destination)=($1,$2);
    my $map=Map->new(source=>$source, destination=>$destination);
    while(<>){
	last if /^$/;
	my ($sd, $ss, $l)=split " ";
	my $range=Range->new(start_source=>$ss, start_destination=>$sd, length=> $l);
	$map->add_range($range);
    }
    return $map;
}
chomp(my $line=<>);
die "Expected seeds" unless $line=~s/^\s*seeds:\s*//i;
my @seeds=split " ", $line;
my %maps;
while(my $map=read_map()){
    $maps{$map->source}=$map;
}
my $best_location;
my $desired="location";
my @pending;
foreach my ($seed, $seed_nvals)(@seeds){
    push @pending, ["seed", $seed, $seed_nvals];
    while(@pending){
	my $source_range=shift @pending;
	my ($source, $initial, $nvals)=@$source_range;
	my $final=$initial+$nvals-1;
	if($source eq $desired){
	    $best_location //= $initial;
	    $best_location=$initial if $initial < $best_location;
	    next;
	}
	my $map=$maps{$source};
	my $destination=$map->destination;
	my $range0=$map->range_before($initial);
	my $range1=$map->range_after($initial);
	undef $range0 if defined $range0 and $range0->end_source < $initial;
	my $half=floor $nvals/2;
	if(not defined $range0){
	    push(@pending, [$destination, $initial, $nvals]), next if not defined $range1;
	    push(@pending, [$destination, $initial, $nvals]), next
		if $final < $range1->start_source;
	    push(@pending, [$source, $initial, $half]);
	    push(@pending, [$source, $initial+$half, $nvals-$half]);
	    next;
	}
	push(@pending, [$destination, $map->destination_of($initial), $nvals]), next
	    if $final <= $range0->end_source;
	push(@pending, [$source, $initial, $half]);
	push(@pending, [$source, $initial+$half, $nvals-$half]);
    }
}
say $best_location;
#+end_src
** Day 6
https://adventofcode.com/2023/day/6
*** Task a
The distance d travelled is equal to the speed v times the available
time (t-v), where t is the total time and the held time is equal to
the speed. Thus, d=vt-v^2. I need d>d_0. Thus, I solve the quadratic
equation v^2-vt-d_0 = 0, and the held time is bounded by the two
solutions.

#+begin_src perl :tangle 6a.pl :shebang #!/usr/bin/env perl
use v5.36;
use POSIX qw(floor ceil);
chomp(my $times=<>);
die "Bad times" unless $times=~s/^\s*Time:\s*(.*)\s*$/$1/i;
my @times=split " ", $times;
chomp(my $distances=<>);
die "Bad distances" unless $distances=~s/^\s*Distance:\s*(.*)\s*/$1/i;
my @distances=split " ", $distances;
die "Wrong dimensions" unless @times==@distances;
my $total=1;
for(0..@times-1){
    my $t=$times[$_];
    my $x=$distances[$_];
    my $s=sqrt($t**2-4*$x);
    my $v0=ceil(($t-$s)/2);
    my $v1=floor(($t+$s)/2);
    my $ways=$v1-$v0+1;
    $ways-=2 if $s==floor($s);
    $total*=$ways;
}
say $total;

#+end_src

*** Task b

#+begin_src perl :tangle 6b.pl :shebang #!/usr/bin/env perl
use v5.36;
use POSIX qw(floor ceil);
chomp(my $t=<>);
die "Bad times" unless $t=~s/^\s*Time:\s*(.*)\s*$/$1/i;
chomp(my $x=<>);
die "Bad distances" unless $x=~s/^\s*Distance:\s*(.*)\s*/$1/i;
s/\s+//g for ($t, $x);
my $s=sqrt($t**2-4*$x);
my $v0=ceil(($t-$s)/2);
my $v1=floor(($t+$s)/2);
my $ways=$v1-$v0+1;
$ways-=2 if $s==floor($s);
say $ways;

#+end_src

** Day 7
https://adventofcode.com/2023/day/7
*** Task a
I make an ranked array of card values and of possible games, each
characterized by an array with ordered card patterns, i.e. [5] (five
of a kind) [4,1] (four of a kind), [3,2] (full house), etc. I build an
array of hands. Each and is characterized by its string representation
and the bid, taken from the input data, the score of the hand
according to their type and an array of the values of each card. Then,
I rank all games by sorting on their scores and if necessary on their
values.

#+begin_src perl :tangle 7a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0 first);
my @cards=qw(2 3 4 5 6 7 8 9 T J Q K A);
my %value_cards;
$value_cards{$cards[$_]}=sprintf "%02d", $_ for 0..@cards-1;
my @games=(11111, 2111, 221, 311, 32, 41, 5);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=card_numbers($hand);
    my $values=join "", map {$value_cards{$_}} split "", $hand;
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {$a->[2] cmp $b->[2] || $a->[3] cmp $b->[3]} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    return join "", sort {$b<=>$a} values %m;
}
#+end_src

*** Task b
The solution is almost identical, but if a hand has jokers besides
other cards, the number of jokers is added to the card that is
repeated the most before scoring.

#+begin_src perl :tangle 7b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0 first);
my @cards=qw(J 2 3 4 5 6 7 8 9 T Q K A);
my %value_cards;
$value_cards{$cards[$_]}=sprintf "%02d", $_ for 0..@cards-1;
my @games=(11111, 2111, 221, 311, 32, 41, 5);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=card_numbers($hand);
    my $values=join "", map {$value_cards{$_}} split "", $hand;
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {$a->[2] cmp $b->[2] || $a->[3] cmp $b->[3]} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    my @sorted=sort {$m{$b}<=>$m{$a}} keys %m;
    for(0..@sorted-1){
	if($sorted[$_] eq "J"){
	    my $add=$m{"J"};
	    if(@sorted>1){ # if other cards
		splice @sorted, $_, 1; # add J to others
		$m{$sorted[0]} += $add;
	    }
	    last;
	}
    }
    return join "", map {$m{$_}} @sorted;
}

#+end_src

** Day 8
https://adventofcode.com/2023/day/8
*** Task a

#+begin_src perl :tangle 8a.pl :shebang #!/usr/bin/env perl
use v5.36;
chomp(my $instructions=<>);
my @instructions=split "", $instructions;
sub next_move() {
    my $move=shift @instructions;
    push @instructions, $move;
    return $move;
}
my %node;
chomp(my $space=<>);
die "Bad format" unless $space=~/^\s*$/;
while(<>){
    /(\w{3})\s*=\s*\((\w{3})\,\s*(\w{3})\s*\)$/
    or die "Bad format";
    my ($f, $l, $r)=($1, $2, $3);
    die if defined $node{$f};
    $node{$f}{L}=$l;
    $node{$f}{R}=$r;
}
die "Missing start" unless defined $node{AAA};
my $current="AAA";
my $steps=0;
while($current ne "ZZZ"){
    ++$steps;
    die "Missing node" unless defined $node{$current};
    $current=$node{$current}{next_move()}
}
say $steps;
#+end_src

*** Task b
The solution is almost identical, but if a hand has jokers besides
other cards, the number of jokers is added to the card that is
repeated the most before scoring. I can step all current nodes a step
at a time until I finish, as in the following code:

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all);
chomp(my $instructions=<>);
my @instructions=split "", $instructions;
sub next_move() {
    my $move=shift @instructions;
    push @instructions, $move;
    return $move;
}
my %node;
chomp(my $space=<>);
die "Bad format" unless $space=~/^\s*$/;
my @current;
while(<>){
    /(\w{3})\s*=\s*\((\w{3})\,\s*(\w{3})\s*\)$/
    or die "Bad format";
    my ($f, $l, $r)=($1, $2, $3);
    die if defined $node{$f};
    $node{$f}{L}=$l;
    $node{$f}{R}=$r;
    push @current, $f if $f=~/A$/;
    $node{$f}{end}=1 if $f=~/Z$/;
}
die "Missing start" unless @current;
my $steps=0;
while(not all {$node{$_}{end}} @current){
    ++$steps;
    my $move=next_move;
    my @next;
    for(@current){
	die "Missing node" unless defined $node{$_};
	push @next, $node{$_}{$move}
    }
    @current=@next;
}
say $steps;
#+end_src

I ran it and it seems to take forever.

I tried several alternatives, trying to find the lengths that take
from a possible ending location to another ending location, so that I
can advance by large steps. But then I would advance by different
number of elementary steps and I would have to synchronize the
different advancing paths. Then I got an inspiration. Since the
general case seem so difficult, maybe the task is easier than the
general case. Maybe the paths are cyclical and from an ending location
they loop back to the starting location. I checked that they do. Then
the solution becomes trivial. I just have to find the lowest common
multiple of all the cycles!

#+begin_src perl :tangle 8b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all);
use Math::Prime::Util qw(lcm);
chomp(my $instructions=<>);
my @instructions=split "", $instructions;
my $num_instructions=@instructions;
my %node;
chomp(my $space=<>);
die "Bad format" unless $space=~/^\s*$/;
my @start;
my %end;
while(<>){
    /(\w{3})\s*=\s*\((\w{3})\,\s*(\w{3})\s*\)$/
    or die "Bad format";
    my ($f, $l, $r)=($1, $2, $3);
    die if defined $node{$f};
    $node{$f}{L}=$l;
    $node{$f}{R}=$r;
    push @start, $f if $f=~/A$/;
    $end{$f}=1  if $f=~/Z$/;
}
die "Missing start" unless @start;
# Find cycle lengths
my @cycles;
for (@start){
    my $current=$_;
    my $t=0;
    $current=$node{$current}{instruction($t++)} while(!$end{$current});
    push @cycles, $t;
}
my $length= lcm(@cycles);
say $length;

sub instruction($step){
    $instructions[$step%$num_instructions];
}
#+end_src

** Day 9
https://adventofcode.com/2023/day/9
*** Task a
To find an extrapolated value I use a recursive procedure.
I use the Perl Data Language which has operators to slice arrays,
operate on all elements of an array, etc. The result is 0 if the array
is made of zeroes. The result is the last element plus the result of
extrapolating the array of first differences. The result is a very
short program.

#+begin_src perl :tangle 9a.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
my $total=0;
while(<>){
    chomp;
    $total += extrapolate(pdl($_));
}
say $total;

sub extrapolate($v){
    return 0 if ($v==0)->all;
    return $v->at(-1)+extrapolate($v(1:-1)-$v(0:-2));
}
#+end_src

It actually fits a one-liner
#+begin_src bash :results output
perl -n -MPDL -MPDL::NiceSlice -E '
sub e($v){return 0 if ($v==0)->all; $v(-1)+e($v(1:-1)-$v(0:-2))}chomp; $t+=e(pdl($_))}{say $t->at(-1)
' 9.txt
#+end_src

Results:
: 1987402313
*** Task b
I believe the code is almost identical. I just subtract from the
leftmost instead of adding to the rightmost.
#+begin_src perl :tangle 9b.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
my $total=0;
while(<>){
    chomp;
    $total += extrapolate(pdl($_));
}
say $total;

sub extrapolate($v){
    return 0 if ($v==0)->all;
    return $v->at(0)-extrapolate($v(1:-1)-$v(0:-2));
}
#+end_src
This also fits a oneliner
#+begin_src bash :results output
perl -n -MPDL -MPDL::NiceSlice -E '
sub e($v){return 0 if ($v==0)->all;$v((0))- e($v(1:-1)-$v(0:-2))}chomp;$t+=e(pdl($_))}{say $t->at(0)
' 9.txt
#+end_src

Results:
: 900
** Day 10
https://adventofcode.com/2023/day/10
*** Task a
I make a hash to map directions to coordinate increments. For each
type of tile, I make a string that describes the in and out directions
and convert it into a map. I find the first tile, any direction which
lands on a valid tile (which can be reached moving in that direction,
i.e., which has that direction as a key in the map. Then I simply
follow directions until I come back to the start. The distance to the
farthest point is half the total length of the path.

#+begin_src perl :tangle 10a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::MoreUtils qw(firstidx);
my %dirs=(R=>[1,0], U=>[0,-1], L=>[-1,0], D=>[0,1]);
my @tiles=qw(JRUDL -RRLL 7RDUL |UUDD FURLD LLUDR s .);
my %map=map {my @t=split ""; @t==5?($t[0]=>{$t[1]=>$t[2], $t[3]=>$t[4]}):()} @tiles;
my @sketch;
my $row=0;
my $current_coords;
while(<>){
    chomp;
    my @row=split "";
    push @sketch, [@row];
    my $col = firstidx {$_ eq "S"} @row;
    $current_coords=[$col,$row] if $col >= 0;
    ++$row;
}
die "No initial tile" unless defined $current_coords;
my $step;
my $tile;
# find and take first step
for(qw(R U L D)){
    my $dir=$dirs{$_};
    my $next_coords = add($current_coords, $dir);
    $tile=tile($next_coords);
    my $next_step=$map{$tile}{$_};
    $current_coords=$next_coords, $step=$_, last if defined $next_step;
}
my $length=1;
# Notice step is out of phase with coords
while($tile ne "S"){
    $step=$map{$tile}{$step};
    die "Shouldn't happen" unless defined $step;
    my $dir=$dirs{$step};
    $current_coords = add($current_coords, $dir);
    $tile=tile($current_coords);
    ++$length;
}
say $length/2;


sub tile($p){
    my @p=@$p;
    return $sketch[$p[1]][$p[0]];
}
sub add($p, $q){
    return [map {$p->[$_]+ $q->[$_]}(0,1)];
}

#+end_src

*** Task b

For the second task I guess I can use the even odd rule to identify
sites within the loop. Tiles not in the path are counted if I can
reach them crossing the path an odd number of times. The problem is to
identify the crossings. Crossings are path fragments that match /|/,
/F-*J/ or /L-*7/.

#+begin_src perl :tangle 10b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::MoreUtils qw(firstidx);
my %dirs=(R=>[1,0], U=>[0,-1], L=>[-1,0], D=>[0,1]);
my @tiles=qw(JRUDL -RRLL 7RDUL |UUDD FURLD LLUDR S .);
my %map=map {my @t=split ""; @t==5?($t[0]=>{$t[1]=>$t[2], $t[3]=>$t[4]}):()} @tiles;
my @sketch;
my $row=0;
my $current_coords;
while(<>){
    chomp;
    my @row=split "";
    push @sketch, [@row];
    my $col = firstidx {$_ eq "S"} @row;
    $current_coords=[$col,$row] if $col >= 0;
    ++$row;
}
die "No initial tile" unless defined $current_coords;
my %in_path;
my $step;
my $tile;
# find and take first step
for(qw(U R D L)){
    my $dir=$dirs{$_};
    my $next_coords = add($current_coords, $dir);
    $tile=tile($next_coords);
    my $next_step=$map{$tile}{$_};
    if(defined $next_step){
	$in_path{"@$current_coords"}=1;
	$current_coords=$next_coords;
	$step=$_;
	last;
    }
}
my $first_step=$step;
# Notice step is out of phase, behind coords and tile
while($tile ne "S"){
    $step=$map{$tile}{$step};
    die "Shouldn't happen" unless defined $step;
    $in_path{"@$current_coords"}=1;
    my $dir=$dirs{$step};
    $current_coords = add($current_coords, $dir);
    $tile=tile($current_coords);
}
my $last_step=$step;
my ($start_x, $start_y)=@$current_coords;
for(keys %map){ # replace starting symbol by correct tile
    next unless defined $map{$_} && defined $map{$_}{$last_step};
    $sketch[$start_y][$start_x]=$_, last if $map{$_}{$last_step} eq $first_step;
}

my $height=@sketch;
my $width=$sketch[0]->@*;
my $count=0;
for my $y (0..$height-1){
    my $odd=0;
    my $enter="";
    my $local_count=0;
    for my $x (0..$width-1){
	my $tile=tile([$x,$y]);
	if($in_path{"$x $y"}){
	    $enter=$tile if $tile=~/[FL]/;
	    $odd=!$odd
		if $tile eq "|"
		or $enter eq "F" and $tile eq "J"
		or $enter eq "L" and $tile eq "7";
	    $enter="" if $tile=~/[J7]/;
	    $count += $local_count;
	    $local_count=0;
	}else{
	    ++$local_count if $odd;
	}
    }
}

say $count;

sub tile($p){
    my @p=@$p;
    return $sketch[$p[1]][$p[0]];
}
sub add($p, $q){
    return [map {$p->[$_]+ $q->[$_]}(0,1)];
}

#+end_src

** Day 11
https://adventofcode.com/2023/day/11
*** Task a
I read the map of the universe into a pdl matrix after changing vacuum
into zeroes and galaxies into ones. For each null row I add
another. Then I transpose the matrix and for each null row (transposed
column) I add another, to get the expanded universe. Finally, for all
pairs of galaxies I add the absolute values of the difference of their
coordinates.

#+begin_src perl :tangle 11a.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
use Algorithm::Combinatorics qw(combinations);
my @universe;
while(<>){
    chomp;
    s/\./0/g;
    s/\#/1/g;
    my $r=pdl split "";
    push @universe, $r;
}
my $universe=pdl(@universe);
my $zero_row=$universe(:,(0))->zeroes;
my @universe_yexpanded;
for(@universe){
    push @universe_yexpanded, $_;
    push @universe_yexpanded, $_ if ($_==0)->all;
}
my $universe_yexpanded=pdl(@universe_yexpanded);
my @universe_xyexpanded;
for($universe_yexpanded->transpose->dog){
    push @universe_xyexpanded, $_;
    push @universe_xyexpanded, $_ if ($_==0)->all;
}
my $universe_expanded=pdl(@universe_xyexpanded)->transpose;
my $galaxies=$universe_expanded->whichND;
my $galaxy_pairs=combinations([$galaxies->dog], 2);
my $sum=0;
while(my $g=$galaxy_pairs->next){
    my $r=pdl($g);
    $sum+=($r(:,(1))-$r(:,(0)))->abs->sumover;
}
say $sum;
#+end_src

*** Task b
For this problem it would make no sense to include additional rows and
columns for the expanded space. What I may do is assign coordinates to
all galaxies and then increment their x or y coordinates if the space
is horizontally or vertically expanded before them. Finally, I simply
subtract the resulting coordinates, take their absolute values and add.

#+begin_src perl :tangle 11b.pl :shebang #!/usr/bin/env perl
use v5.36;
use v5.36;
my $factor=1000000; # expansion factor
use PDL;
use PDL::NiceSlice;
use Algorithm::Combinatorics qw(combinations);
my @universe;
while(<>){
    chomp;
    s/\./0/g;
    s/\#/1/g;
    my $r=pdl split "";
    push @universe, $r;
}
my $universe=pdl(@universe);
my $galaxies=$universe->whichND; # get coordinates of galaxies
my $expansion_x=(!$universe->transpose->orover)->which;
my $expansion_y=(!$universe->orover)->which;
my $xcoords=sequence($universe->dim(0));
for($expansion_x->dog){
    $xcoords($_:-1)+=$factor-1;
}
my $ycoords=sequence($universe->dim(1));
for($expansion_y->dog){
    $ycoords($_:-1)+=$factor-1;
}
my $galaxy_pairs=combinations([$galaxies->dog], 2);
my $sum=0;
while(my $g=$galaxy_pairs->next){
    my($r0, $r1)=map{pdl($_)}@$g;
    for($r0, $r1){
	$_(0).=$xcoords($_((0)));
	$_(1).=$ycoords($_((1)));
    }
    $sum+=($r1-$r0)->abs->sumover;
}
say $sum;
#+end_src

** Day 12
https://adventofcode.com/2023/day/12
*** Task a
After a long time trying different solutions I read a comment by Adam
Crussel mentioning he saw a solution in Sed. I didn't look at that
solution, but tried my own with a regular expression. It was really
simple using the possibility of executing code (incrementing a
counter) after matching and then forcing failure so that the regular
expression tries the next match. It took only a few minutes to read
about code execution within regular expressions and forcing failure. I
build the regular expression for each line

#+begin_src perl :tangle 12a.pl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
while(<>){
    chomp;
    my ($condition,$duplicate)=split " ";
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
}
say $count;
#+end_src

This is the same, but compressed to a two-liner.
#+begin_src bash :results output
time perl -Mre=eval -E '
$c=0;while(<>){chomp;($s,$d)=split " ";@n=split ",", $d;$re="^[.?]*" . join("[.?]+",
map {"[?#]{$_}"} @n) . "[?.]*\$(?{++\$c})(*FAIL)";$s=~/$re/;}say $c;
' 12.txt
#+end_src

Results:
: 7653


*** Task b
The second task seems relatively trivial. I make the indicated
replacements and run the code of the previous task.
#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
while(<>){
    chomp;
    my ($condition,$duplicate)=split " ";
    $condition=join "?", (("$condition") x 5); # unfold
    $duplicate=join ",", (("$duplicate") x 5);
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
}
say $count;
#+end_src


However, this takes forever. A simplistic solution would be to solve the first
problem and raise each row to the fifth power. It doesn't work as the
joining springs may be failed. Another alternative is to separate the cases
where all the joining springs work (the fifth power of the previous
task), where all work except one (the fourth power of the  previous
task times the result for two records joined by a failing spring)
multiplied by the four positions for the failed joining spring,
plus... Not sure if it will be fast enough nor if it's correct. I am
assuming that when two records are joind by a working spring, there
are no solutions that cross records.

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
my $total;
while(<>){
    chomp;
    say $.;
    my ($condition,$duplicate)=split " ";
    my ($c1, $c2, $c3, $c4, $c5)=map {
	solve((join "#", (("$condition") x $_)),(join ",", (("$duplicate") x $_)));
    } 1..5;
    my $subtotal=$c1**5 + 4*$c2*$c1**3 + 3*$c2**2*$c1 + 3*$c3*$c1**2 + 2*$c3*$c2 + 2*$c4*$c1 + $c5;
    $total += $subtotal;
}
say $total;

sub solve($condition, $duplicate){
    my $count=0;
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
    return $count;
}

#+end_src

This didn't work either. I try now the first approach, but simplifying
the pattern first, using single '.' as separator. I'm not optimistic.

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use re qw(eval);
my $count=0;
while(<>){
    chomp;
    my ($condition,$duplicate)=split " ";
    $condition=join "?", (("$condition") x 5); # unfold
    $condition.="."; # add guard
    $condition=~s/\.+/./; # shorten separators
    $duplicate=join ",", (("$duplicate") x 5);
    my @nfails=split ",", $duplicate;
    my $re="^[.?]*" . join("[.?]+", map {"[?#]{$_}"} @nfails) . '[?.]*$(?{++$count})(*FAIL)';
    $condition=~/$re/;
    say $.;
}
say $count;
#+end_src

No, it didn't work.

I guess a solution might be to make a regular expression to match the
first series of damaged springs. On success, recurse for the rest of the
series and the rest of the records. Then, if the matched string starts
with a ?, eliminate the starting character and search again for more
matches. I also memoize the recursive calls to gain speed.

#+begin_src perl :shebang #!/usr/bin/env perl :tangle 12b.pl
use v5.36;
use Memoize;
memoize("howmany");
my $total=0;
my $copies=5;
while(<>){
    chomp;
    my ($record,$duplicate)=split " ";
    $record=join "?", (("$record") x $copies); # unfold
    $record.="."; # add guard
    $record=~s/\.+/./; # shorten separators
    $duplicate=join ",", (("$duplicate") x $copies);
    my @ndamaged=split ",", $duplicate;
    my $count=howmany($record, @ndamaged);
    $total += $count;
}
say $total;

sub howmany($record, @ndamaged){
    my $count=0;
    return $record=~/#/?0:1 unless @ndamaged;
    my $damaged=shift @ndamaged;
    while($record && $record=~s/^[^#]*?([?#]{$damaged}[^#])//){
	my $matched=$1;
	my $found = howmany($record, @ndamaged);
	$count += $found;
	last if $matched=~/^#/;
	$matched=~s/^.//; #shorten next record
	$record=$matched.$record;
    }
    return $count;
}

#+end_src

** Day 13
https://adventofcode.com/2023/day/13
*** Task a

#+begin_src perl :tangle 13a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all min);
local $/=""; # paragraph at a time
my $total=0;
while(<>){
    my @rows=split /^/;
    pop @rows if $rows[-1]=~/^$/; # remove empty line
    chomp for @rows;
    my $width=length $rows[0];
    my $height=@rows;
    my @cols;
    for (0..@rows-1){
	my @row=split "", $rows[$_];
	$cols[$_].=$row[$_] for 0..$width-1;
    }
    my @horizontal=search_mirror(@rows);
    my @vertical=search_mirror(@cols);
    $total+=($_+1)*100 for @horizontal;
    $total+=$_+1 for @vertical;
}
say $total;

sub search_mirror(@arr){ # search mirror plane
    my $N=@arr;
    my @c;
    for my $c(0..$N-2){
	my $m=min($c, $N-2-$c);
	push @c, $c if all {$arr[$c-$_] eq $arr[$c+1+$_]} (0..$m);
    }
    return @c;
}

#+end_src


*** Task b
According to the statement, there is exactly one horizontal or
vertical mirror that produces a perfect image except at one
position. The problem is to locate it. I simply count how many errors
would be present for all potential mirrors. If there is only one
error, that is the mirror. I need not correct the error, as I only
need the mirror's number.

#+begin_src perl :tangle 13b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(min);
local $/=""; # paragraph at a time
my %exchange=("."=>"#", "#"=>".");
my $total=0;
while(<>){
    my @rows=split /^/;
    pop @rows if $rows[-1]=~/^$/; # remove empty line
    chomp for @rows;
    my $width=length $rows[0];
    my $height=@rows;
    my @sketch;
    push @sketch, [split "", $_] for @rows;
    my $h=analyze(@sketch);
    my $v=analyze(transpose(@sketch));
    $total+=100*$h+$v;
}
say $total;

sub analyze(@arr){ # search mirror planes
    my $height=@arr;
    my $width=@{$arr[0]};
    for my $r(0..$height-2){ # for each possible mirror
	my $errs; # number of errors
	my $m=min($r, $height-2-$r);
	for(0..$m){ # for each object-image pair
	    for my $c(0..$width-1){
		my $diff=$arr[$r-$_][$c] ne $arr[$r+1+$_][$c];
		$errs+=$diff;
	    }
	}
	return $r+1 if($errs==1); #assume only one mirror with exactly one smudge
    }
    return 0;
}

sub transpose(@arr){
    my @res;
    return @res unless @arr;
    my $height=@arr;
    my $width=@{$arr[0]} if $height;
    for my $i(0..$height-1){
	for my $j(0..$width-1){
	    $res[$j][$i]=$arr[$i][$j];
	}
    }
    return @res;
}

#+end_src

** Day 14
https://adventofcode.com/2023/day/14
*** Task a
After reading the diagram, I exchange the rows by columns, so that I
may replace the original columns by strings. I use a regular
expression to repeatedly move rounded rocks to the left (originally
up) over empty space. Then I calculate the load.

#+begin_src perl  :tangle 14a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all min);
my $total=0;
while(my $row_strings=diagram()){
    my $rows=to_matrix($row_strings);
    my $cols=ref_diag($rows);
    my $newcols=tilt_left($cols);
    my $load=load($newcols);
    say $load;
}
sub load($arr){
    my $length=@$arr;
    my $load=0;
    for(@$arr){
	my @col=@$_;
	$load+=$col[$_]eq "O"?$length-$_:0 for(0..@col-1);
    }
    return $load;
}

sub tilt_left($arr){
    my @newarr;
    for(@$arr){
	my $col=join "", @$_;
	1 while $col=~s/(\.+)(O+)/$2$1/g;
	push @newarr, [split "", $col];
    }
    return \@newarr;
}

sub ref_diag($arr){ # reflection on main diagonal
    my @in=@$arr;
    my @cols;
    for my $i(0..@in-1){
	my @row=@{$in[$i]};
	$cols[$_][$i]=$row[$_] for(0..@row-1);
    }
    return \@cols;
}

sub diagram(){
    # read a complete diagram
    local $/=""; # paragraph at a time
    local $_=<>;
    return unless $_;
    my @row_strings=split /^/;
    pop @row_strings if $row_strings[-1]=~/^$/; # remove empty line
    chomp($_) for @row_strings;
    return \@row_strings if @row_strings;
    return;
}
sub to_matrix($rows){
    my @rows=map {[split ""]} @$rows;
    return \@rows;
}
sub transpose($arr){
    my @arr=@$arr;
    my $height=@arr;
    my $width=@{$arr[0]};
    my @out;
    for my $c(0..$width-1){
	push @out, [map {$arr[$_][$c]} 0..$height-1]
    }
    return \@out;
}
#+end_src

*** Task b
West becomes north after a clockwise rotation by 90 degrees, which may
be accomplished by reflecting along the diagonal (i.e., transposing
the matrix) and then reflecting vertically, i.e., reversing the order
of the rows. A straightforward solution would then be to tilt and then
rotate four times and then repeat the cycle 1000000000 times, and
evaluate the final configuration. I guess 1e9 repetitions is too much,
as the arrangement might converge much earlier. To that end, I make an
image of the system and terminate early if the image repeats.

#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all min);
my $N=1000000000;
my $total=0;
while(my $row_strings=diagram()){
    my $rows=to_matrix($row_strings);
    my $cols=ref_vert(ref_diag($rows));
    my $image=join "\n", map {join "", @$_} @$cols;
    for(1..$N){
	$cols=cycle($cols);
	if($_%1000==0){
	    say $_;
	    my $prev_image=$image;
	    $image=join "-", @$cols;
	    last if $image eq $prev_image;
	}
    }
    my $load=load($cols);
    say $load;
}
sub cycle($arr){
    my $out=$arr;
    $out=rotate_right(tilt_left($out)) for (1..4);
    return $out;
}

sub load($arr){
    my $length=@$arr;
    my $load=0;
    for(@$arr){
	my @col=@$_;
	$load+=$col[$_]eq "O"?$length-$_:0 for(0..@col-1);
    }
    return $load;
}

sub tilt_left($arr){
    my @newarr;
    for(@$arr){
	my $col=join "", @$_;
	1 while $col=~s/(\.+)(O+)/$2$1/g;
	push @newarr, [split "", $col];
    }
    return \@newarr;
}

sub ref_diag($arr){ # reflection on main diagonal
    my @in=@$arr;
    my @cols;
    for my $i(0..@in-1){
	my @row=@{$in[$i]};
	$cols[$_][$i]=$row[$_] for(0..@row-1);
    }
    return \@cols;
}
sub ref_vert($arr){ # reflect vertically
    my @in=@$arr;
    my @out= reverse @in;
    return \@out;
}

sub rotate_right($arr){
    return ref_diag(ref_vert($arr));
}

sub diagram(){
    # read a complete diagram
    local $/=""; # paragraph at a time
    local $_=<>;
    return unless $_;
    my @row_strings=split /^/;
    pop @row_strings if $row_strings[-1]=~/^$/; # remove empty line
    chomp($_) for @row_strings;
    return \@row_strings if @row_strings;
    return;
}
sub to_matrix($rows){
    my @rows=map {[split ""]} @$rows;
    return \@rows;
}
sub transpose($arr){
    my @arr=@$arr;
    my $height=@arr;
    my $width=@{$arr[0]};
    my @out;
    for my $c(0..$width-1){
	push @out, [map {$arr[$_][$c]} 0..$height-1]
    }
    return \@out;
}
#+end_src

Of course, the image did not repeat immediatly, the cycle did not
converge, but there might be a cycle limit, after a while the sequence
of patterns might repeat periodically. I use a hash to detect a loop,
its start and period.

#+begin_src perl :tangle 14b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all min);
my $N=6;
my $total=0;
while(my $row_strings=diagram()){
    my $rows=to_matrix($row_strings);
    my $cols=ref_vert(ref_diag($rows));
    my %seen;
    my ($start, $end); # start and end of cycle
    my @pics;
    for(0..$N-1){
	my $pic=join "\n", map {join "", @$_} @$cols;
	($start, $end)=($seen{$pic}, $_), last if defined $seen{$pic};
	push @pics, $pic; # Notice push before cycling
	$seen{$pic}=$_;
	$cols=cycle($cols);
    }
    if(defined($start)){ # found cycle
	my $cycle_length=$end-$start;
	my $Nmod=($N-$start)%$cycle_length; # not $N-1 cause I pushed before cycling
	my $pic=$pics[$Nmod+$start];
	$cols=[map {chomp; [split ""]} split /^/, $pic];
    }
    my $load=load($cols);
    say $load;
}
sub cycle($arr){
    my $out=$arr;
    $out=rotate_right(tilt_left($out)) for (1..4);
    return $out;
}

sub load($arr){
    my $length=@$arr;
    my $load=0;
    for(@$arr){
	my @col=@$_;
	$load+=$col[$_]eq "O"?$length-$_:0 for(0..@col-1);
    }
    return $load;
}

sub tilt_left($arr){
    my @newarr;
    for(@$arr){
	my $col=join "", @$_;
	1 while $col=~s/(\.+)(O+)/$2$1/g;
	push @newarr, [split "", $col];
    }
    return \@newarr;
}

sub ref_diag($arr){ # reflection on main diagonal
    my @in=@$arr;
    my @cols;
    for my $i(0..@in-1){
	my @row=@{$in[$i]};
	$cols[$_][$i]=$row[$_] for(0..@row-1);
    }
    return \@cols;
}
sub ref_vert($arr){ # reflect vertically
    my @in=@$arr;
    my @out= reverse @in;
    return \@out;
}

sub rotate_right($arr){
    return ref_diag(ref_vert($arr));
}

sub diagram(){
    # read a complete diagram
    local $/=""; # paragraph at a time
    local $_=<>;
    return unless $_;
    my @row_strings=split /^/;
    pop @row_strings if $row_strings[-1]=~/^$/; # remove empty line
    chomp($_) for @row_strings;
    return \@row_strings if @row_strings;
    return;
}
sub to_matrix($rows){
    my @rows=map {[split ""]} @$rows;
    return \@rows;
}
sub transpose($arr){
    my @arr=@$arr;
    my $height=@arr;
    my $width=@{$arr[0]};
    my @out;
    for my $c(0..$width-1){
	push @out, [map {$arr[$_][$c]} 0..$height-1]
    }
    return \@out;
}
#+end_src

** Day 15
https://adventofcode.com/2023/day/15
*** Task a
The first part is solved by following the instructions straightforwardly.

#+begin_src perl  :tangle 15a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $total=0;
while(<>){
    chomp;
    for(split ","){
	my $hash=0;
	$hash = ($hash+ord)*17%256 for(split "");
	$total += $hash;
    }
}
say $total;
#+end_src

*** Task b
I make an array of boxes, each with an array of lenses, each a hash
with the focal length and a label. I use splice to remove and or
exchange lenses, compacting the array.

#+begin_src perl :tangle 15b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::MoreUtils qw(firstidx);
my @boxes;
while(<>){
    chomp;
    for(split ","){
	/(.*)([=-])(.*)/;
	my ($label,$operation,$focal) =($1,$2,$3);
	my $nbox=hash($label);
	my $box=$boxes[$nbox];
	if($operation eq "-"){
	    my $pos = firstidx {$_->{label} eq $label} $box->@*;
	    splice $box->@*, $pos, 1 if $pos>=0;
	}else{ # $operation eq "=")
	    my $lens={label=>$label, focal=>$focal};
	    my $pos = firstidx {$_->{label} eq $label} $box->@*;
	    push $box->@*, $lens if $pos==-1;
	    splice $box->@*, $pos, 1, $lens if $pos >= 0;
	}
	$boxes[$nbox]=$box;
    }
}
my $total=0;
my $nbox=0;
for(@boxes){
    ++$nbox;
    next unless $_;
    my $power=0;
    my $slot=0;
    for($_->@*){
	++$slot;
	$power+=$nbox*$slot*$_->{focal};
    }
    $total+=$power;
}
say $total;

sub hash($label){
    my $hash=0;
    $hash = ($hash+ord)*17%256 for(split "", $label);
    return $hash;
}

#+end_src

***

** Day 16
https://adventofcode.com/2023/day/16
*** Task a
I need an queue of pending beams to follow, each characterized by current position and
direction. I also need an array of directions of beams that have been found for each
site. Better yet, I can use a bit mask of beam directions for each visited
site. If a beam lands on a site which a beam has already visited with
the same direction, I am done with that beam and start with the next
one until exhausted. At each iteration I shift a beam from the queue,
advance, check the device and push the new position and new possible
directions (two for splitters met normally, one for the others) into
the beam queue.

#+begin_src perl  :tangle 16a.pl :shebang #!/usr/bin/env perl
use v5.36;
my %mask=(right=>1,     up=>2,      left=>4,      down=>8);
my %steps=(right=>[1,0], up=>[0,-1], left=>[-1,0], down=>[0,1]);
my %next_dirs=(
    "." =>{right=>["right"],      up=>["up"],
	  left=>["left"],        down=>["down"]},
    "-" =>{right=>["right"],      up=>["right", "left"],
	  left=>["left"],        down=>["right", "left"]},
    "/" =>{right=>["up"],         up=>["right"],
	  left=>["down"],        down=>["left"]},
    "|" =>{right=>["up", "down"], up=>["up"],
	  left=>["up", "down"],  down=>["down"]},
    "\\"=>{right=>["down"],       up=>["left"],
	   left=>["up"],		 down=>["right"]}
    );


my @devices;
while(<>){
    chomp;
    push @devices, [split ""];
}
my $height=@devices;
my $width=$devices[0]->@*;
my @dirs=map {[(0) x $width]} 0..$height-1;
my @pending_beams;
push @pending_beams, [-1,0,"right"];
my $total;
while(@pending_beams){
    my ($x, $y, $dir)=(shift @pending_beams)->@*;
    ($x,$y)=add([$x,$y], $steps{$dir})->@*;
    next if $x<0 or $x>=$width or $y<0 or $y>=$height;
    my $dir_mask = $mask{$dir};
    next if $dirs[$y][$x] & $dir_mask;
    ++$total unless $dirs[$y][$x];
    $dirs[$y][$x] |= $dir_mask;
    my $device=$devices[$y][$x];
    my $next_dirs=$next_dirs{$device}{$dir};
    push @pending_beams, map{[$x, $y, $_]} $next_dirs->@*;
}
say $total;

sub add($p, $q){
    return [map {$p->[$_]+$q->[$_]} 0..@$p-1];
}

#+end_src
*** Task b
A straight forward solution would be to test all possible starting
configurations and pick the best. My suspicion is that it won't work,
but I'll try.

#+begin_src perl :tangle 16b.pl :shebang #!/usr/bin/env perl
use v5.36;
my %mask=(right=>1,     up=>2,      left=>4,      down=>8);
my %steps=(right=>[1,0], up=>[0,-1], left=>[-1,0], down=>[0,1]);
my %next_dirs=(
    "." =>{right=>["right"],      up=>["up"],
	  left=>["left"],        down=>["down"]},
    "-" =>{right=>["right"],      up=>["right", "left"],
	  left=>["left"],        down=>["right", "left"]},
    "/" =>{right=>["up"],         up=>["right"],
	  left=>["down"],        down=>["left"]},
    "|" =>{right=>["up", "down"], up=>["up"],
	  left=>["up", "down"],  down=>["down"]},
    "\\"=>{right=>["down"],       up=>["left"],
	   left=>["up"],		 down=>["right"]}
    );

my @devices;
while(<>){
    chomp;
    push @devices, [split ""];
}
my $height=@devices;
my $width=$devices[0]->@*;
my @dirs=map {[(0) x $width]} 0..$height-1;
my @pending_beams;

my @initial_conditions=(
    (map {[-1, $_, "right"]} 0..$height-1),
    (map {[$_, $height, "up"]} 0..$width-1),
    (map {[$width, $_, "left"]} 0..$height-1),
    (map {[$_, -1, "down"]} 0..$width-1)
    );

my $total=0;
for(@initial_conditions){
    my @dirs_copy=map {[@$_]} @dirs;
    my $energized=0;
    push @pending_beams, $_;
    while(@pending_beams){
	my ($x, $y, $dir)=(shift @pending_beams)->@*;
	($x,$y)=add([$x,$y], $steps{$dir})->@*;
	next if $x<0 or $x>=$width or $y<0 or $y>=$height;
	my $dir_mask = $mask{$dir};
	next if $dirs_copy[$y][$x] & $dir_mask;
	++$energized unless $dirs_copy[$y][$x];
	$dirs_copy[$y][$x] |= $dir_mask;
	my $device=$devices[$y][$x];
	my $next_dirs=$next_dirs{$device}{$dir};
	push @pending_beams, map{[$x, $y, $_]} $next_dirs->@*;
    }
    $total=$energized if $energized>$total;
}
say $total;

sub add($p, $q){
    return [map {$p->[$_]+$q->[$_]} 0..@$p-1];
}

#+end_src

It did work! 4 seconds or so. Maybe not too efficient, but enough for
this task.

** Day 17
https://adventofcode.com/2023/day/17
*** Task a
I can start at the end and label each possible path with the minimum
cost to reach the end from it. I setup a queue of blocks that have to
be inspected. If they have not been considered yet, or if the current
route is better than the previous routes that have visited that block,
I update its cost and add its neighbors to the queue. As there is a
constriction on the paths, I actually have to register the cost for
each block and each direction. As the number of straight steps is
bounded, I have to distiguish multiple steps. To that end, I label single
steps as >, ^, <, v, and repeated steps as >>, >>>, ^, ^^, etc.

#+begin_src perl  :tangle 17a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(min);
my %steps=(">"=>[1,0], "^"=>[0,-1], "<"=>[-1,0], "v"=>[0,1]);
my %opposite=(">"=>"<", "^"=>"v", "<"=>">", "v"=>"^");
my @blocks;
while(<>){
    chomp;
    last if /^$/;
    push @blocks, [split ""];
}
my $height=@blocks;
my $width=$blocks[0]->@*;
my @cost;
my @pending;
push @pending, [$width, $height-1,">",0], [$width-1, $height,"v",0];
while(@pending){
    my ($x, $y, $dir, $cost)=(shift @pending)->@*;
    my $first=substr $dir,0,1;
    ($x, $y)=subtract([$x,$y], $steps{$first})->@*;
    next if $x<0 or $x>=$width or $y<0 or $y>=$height;
    my $current_cost=$cost[$y][$x];
    my $visited=defined $current_cost && defined $current_cost->{$dir};
    my $change=!$visited || $current_cost->{$dir}>$cost;
    next unless $change; # been here on better path
    $cost[$y][$x]{$dir}=$cost; # set new cost of path from here to end
    $cost+=$blocks[$y][$x]; # update cost

    for(keys %steps){
	my $next_dir = $_;
	$next_dir .= $dir if $next_dir eq $first; # consecutive steps
	next if length $next_dir > 3;
	next if $_ eq $opposite{$first};
	push @pending, [$x, $y, $next_dir, $cost]
    }
}
my @totals=values $cost[0][0]->%*;
my $total=min @totals;
say $total;

sub subtract($p, $q){
    return [map {$p->[$_]-$q->[$_]} 0..@$p-1];
}

#+end_src

The code works, but slowly (it took more than 4mins in my laptop).

*** Task b

At first I took the code above and changed the maximum step from >>>
to >>>>>>>>>>, and so on, and I included a minimum step >>>>. I didn't
queue turns for blocks arrived with less than the minimum number of
steps. I noticed that in the first task I made an off by one error
which could have, but didn't produce a wrong result. The problem is
that for simplicity I started queuing the blocks beyond the end
position, so that going backwards I would arrive at the end
position. However, resulting error is that there are duplicate
for the last leg of the path. If the last leg is ">>>" ending in the
final block, I get another one, ">>>>" that ends just beyond. It took
me awhile to find and correct this mistake. The code is somewhat more
involved, but it does work. My solution is still slower than that of
part 1 (around 6mins), but it worked.

#+begin_src perl  :tangle 17b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(min);
my $min_length=4;
my $max_length=10;
my %steps=(">"=>[1,0], "^"=>[0,-1], "<"=>[-1,0], "v"=>[0,1]);
my @dirs=sort keys %steps;
my %opposite=(">"=>"<", "^"=>"v", "<"=>">", "v"=>"^");
my @blocks;
while(<>){
    chomp;
    last if /^$/;
    push @blocks, [split ""];
}
my $height=@blocks;
my $width=$blocks[0]->@*;
my @cost;
$cost[$height-1][$width-1]={"", 0};
my @pending;
push @pending, map{[$width-$_->[0], $height-$_->[1],$_->[2],
		    $blocks[$height-1][$width-1]]}
                    ([2,1,">"], [1,2,"v"]);
while(@pending){
    my ($x, $y, $dir, $cost)=(shift @pending)->@*;
    my $first=substr $dir,0,1;
    next if $x<0 or $x>=$width or $y<0 or $y>=$height;
    my $current_cost=$cost[$y][$x];
    my $visited=defined $current_cost && defined $current_cost->{$dir};
    my $change=!$visited || $current_cost->{$dir}>$cost;
    next unless $change; # been here on better path
    $cost[$y][$x]{$dir}=$cost; # set new cost of path from here to end
    $cost+=$blocks[$y][$x]; # update cost

    for(@dirs){
	my $next_dir = $_;
	$next_dir .= $dir if $next_dir eq $first; # consecutive steps
	next if length $next_dir > $max_length; # don't turn late
	next if $_ eq $opposite{$first};
	next if $_ ne $first and length $dir < $min_length; # don't turn early
	my ($nx,$ny)=subtract([$x,$y], $steps{$_})->@*;
	push @pending, [$nx, $ny, $next_dir, $cost]
    }
}
my %totals=$cost[0][0]->%*;
my @totals=map {
    $totals{$_}
} grep {length $_ >= $min_length && length $_ <=$max_length}
keys %totals;
my $total=min @totals;
say $total;

sub subtract($p, $q){
    return [map {$p->[$_]-$q->[$_]} 0..@$p-1];
}

#+end_src

** Day 18
https://adventofcode.com/2023/day/18
*** Task a
A simplistic solution would be to record all corners of the resulting
closed polygon, and compute the total area by adding cross products of
the corners. That yields the geometric area. The problem is that the
lines have a width, so they also contribute to the area, so I need the
corners of the hull that encloses those wide lines too. An alternative
is to consider the perimeter also. Centering each cube hole at integer
coordinates, and dividing each into four equal parts, each contributes
2 parts at each straight segment, 3 parts at each convex turn and 1
part at each concave turn, so the result is the area plus half the
perimeter plus a fourth of the number of convex minus concave
turns. For a rectangle there are exactly four convex turns. For any
other figure, each concave turn has to be compensated by a convex
turn. So in total I have to add 4/4=1 from all the corners.

#+begin_src perl  :tangle 18a.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
my %dirs=(R=>pdl(1,0), U=>pdl(0,-1), L=>pdl(-1,0), D=>pdl(0,1));
my $first=my $current=pdl(0,0);
my @border=($first);
my @edges;
while(<>){
    chomp;
    last if /^$/;
    die "Wrong input" unless /([RULD])\s+(\d*)\s+\((#[0-9a-f]{6})\)/;
    my ($dir, $dist, $color)=($1, $2, $3);
    $current= $current+(my $edge=$dist*$dirs{$dir});
    push @border, $current;
    push @edges, $edge;
}
die "Not a cycle" unless ($current==$first)->all;
my $border=pdl(@border);
my $perimeter=pdl(@edges)->abs->sumover->sumover;
my $area=cross($border(:,0:-2), $border(:,1:-1))->sumover->abs/2;
my $result=$area+$perimeter/2+1;
say $result;


sub cross($p, $q){
    return pdl($p((0))*$q((1))-$p((1))*$q((0)));
}
#+end_src


*** Task b

The algorithm is the same, I just have to decode the instructions for
each line using a regular expression.

#+begin_src perl  :tangle 18b.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
#my %dirs=(R=>pdl(1,0), U=>pdl(0,-1), L=>pdl(-1,0), D=>pdl(0,1));
my @dirs=(pdl(1,0), pdl(0,1), pdl(-1,0), pdl(0,-1));
my $first=my $current=pdl(0,0);
my @border=($first);
my @edges;
while(<>){
    chomp;
    last if /^$/;
    die "Wrong input" unless /([RULD])\s+(\d*)\s+\(#([0-9a-f]{5})([0-3])\)/;
    my ($olddir, $olddist, $disthex, $dirnum)=($1, $2, $3,$4);
    my $dist=hex $disthex;
    $current= $current+(my $edge=$dist*$dirs[$dirnum]);
    push @border, $current;
    push @edges, $edge;
}
die "Not a cycle" unless ($current==$first)->all;
my $border=pdl(@border);
my $perimeter=pdl(@edges)->abs->sumover->sumover;
my $area=cross($border(:,0:-2), $border(:,1:-1))->sumover->abs/2;
my $result=$area+$perimeter/2+1;
say $result;


sub cross($p, $q){
    return pdl($p((0))*$q((1))-$p((1))*$q((0)));
}
#+end_src

** Day 19
https://adventofcode.com/2023/day/19
*** Task a
The simple solution is to follow the rules. It should scale if there
is really no loop. Each workflow name is mapped to an array of codes of
the form [category, test, threshold, next] and for each piece I build
a hash that maps categories into values. With them, it is simple to
follow the instructions intul the piece is rejected or accepted. I use
the ability of perl to get elegantly jump across iterated loops.

#+begin_src perl  :tangle 19a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(sum0);
my %workflows;
while(<>){ # read workflows
    chomp;
    last if /^\s*$/;
    /^\s*(\w+)\s*\{(.*)\}/ or die "wrong format";
    my ($name,$instructions)=($1,$2);
    my @instructions=split /\s*,\s*/, $instructions;
    my @codes; # [category, test, threshold, next]
    for(@instructions){
	push @codes, ["", "", "", $1] if /^\s*(\w+)\s*$/;
	push @codes, [$1, $2, $3, $4] if /\s*(\w+)\s*([><])\s*(\d+)\s*:\s*(\w+)\s*$/;
    }
    $workflows{$name}=[@codes];
}
die "Missing in" unless defined $workflows{in};
my @parts;
my $total;
while(<>){ # read parts
    s/\s*{\s*// and s/\s*}\s*// or die "Wrong format";
    my %values;
    for(split /\s*,\s*/){
	/^\s*([xmas])\s*=\s*(\d+)\s*$/ or die "Wrong format";
	$values{$1}=$2;
    }
    $total+=rating(%values);
}
say $total;

sub rating(%values){
    my $wf="in";
  WF: while($wf!~/[AR]/){
      my @codes=$workflows{$wf}->@*;
      for(@codes){
	  my ($category, $test, $threshold, $next)=@$_;
	  $wf=$next, next WF if
	      $test eq ""
	      || $test eq ">" && $values{$category} > $threshold
	      || $test eq "<" && $values{$category} < $threshold
      }
      die "Shouldn't get here"; # no match nor default
  }
    return sum0 values %values if $wf eq "A";
}

#+end_src


*** Task b
I build an inverse mapping, from which workflow can I land in a given
workflow for categories in which intervals. Then I start at the Accept
state and work backwards. For each workflow a, each workflow b that
reaches a for intervals I_{ab} and each workflow c that reaches b with
intervals I_{bc}, I may replace workflow b by workflow c, which may
reach a for intervals I_{ac}=intersection of I_b and I_c. If I_c could
reach a before, then I make the union of the previous intervals to get
the full set of intervals that reach a from c. I continue eliminating
intermediate workflows until the only one is /in/, and then I use the
resulting set of intervals to calculate the total number of
acceptable combinations.

#+begin_src perl  :tangle 19b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(min max sum0 product);
my %workflows;
while(<>){ # read workflows
    chomp;
    last if /^\s*$/;
    /^\s*(\w+)\s*\{(.*)\}/ or die "wrong format";
    my ($name,$instructions)=($1,$2);
    my @instructions=split /\s*,\s*/, $instructions;
    my @codes; # [category, test, threshold, next]
    for(@instructions){
	push @codes, ["", "", "", $1] if /^\s*(\w+)\s*$/;
	push @codes, [$1, $2, $3, $4] if /\s*(\w+)\s*([><])\s*(\d+)\s*:\s*(\w+)\s*$/;
    }
    $workflows{$name}=[@codes];
}
die "Missing in" unless defined $workflows{in};
my %backflows;
for my $wf(keys %workflows){
    my @codes=$workflows{$wf}->@*;
    my @intervals;
    push @intervals, {x=>[1,4000], m=>[1,4000], a=>[1,4000], s=>[1,4000]};
    for my $code (@codes){
	my($category, $test, $threshold, $next)=@$code;
	my @next_intervals;
	for(@intervals){
	    push($backflows{$next}->@*, [$wf, {%$_}]), next if $category eq "";
	    my ($newlow, $newhigh)= my ($low, $high)=my @interval=$_->{$category}->@*;
	    $newlow=$threshold+1 if $test eq ">";
	    $newhigh=$threshold-1 if $test eq "<";
	    push $backflows{$next}->@*, [$wf, {%$_, $category=>[$newlow, $newhigh]}]
	       if $newlow<=$newhigh;
	    push @next_intervals, {%$_, $category=>[$low, $newlow-1]} if $low<$newlow;
	    push @next_intervals, {%$_, $category=>[$newhigh+1, $high]} if $newhigh<$high;
	}
	@intervals=@next_intervals;
    }
}
my @results=merge("A");
my $total=0;
for(@results){
    my $product = product map {1+$_->[1]-$_->[0]} values %$_;
    $total += $product;
}
say $total;

sub merge($wf){
    state $all={x=>[1,4000], m=>[1,4000], a=>[1,4000], s=>[1,4000]};
    return ($all) if($wf eq "in");
    my @bf=$backflows{$wf}->@*; #from {codes}
    my @result;
    for(@bf){
	my @previous_codes=merge($_->[0]);
	my $current_code=$_->[1];
	push @result, grep {$_} map {code_intersect($current_code, $_)} @previous_codes;
    }
    return @result;
}

sub code_intersect($c1, $c2){
    my %result;
    for(keys %$c1){
	my $intersection=intersection($c1->{$_}, $c2->{$_});
	return unless $intersection;
	$result{$_}=$intersection;
    }
    return {%result};
}


sub intersection(@intervals){
    return unless @intervals;
    return @intervals if @intervals==1;
    my $low=max map {$_->[0]} @intervals;
    my $high=min map {$_->[1]} @intervals;
    return [$low,$high] if $low<=$high;
    return;
}
#+end_src

** Day 20
https://adventofcode.com/2023/day/20
*** Task a
I make a hash of modules indexed by its name and described by its
kind, a routine that proceses its inputs, its state, destinations and
the modules from which it receives input. Each time a module outputs a
signal, I add an array to a queue with its name, the pulse and the
destinatary. Each push of the button starts populating and emptying
the queue until it is empty and it is time to push the button again.

#+begin_src perl  :tangle 20a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all);
my $N=1000; # number of iterations
my %modules; #name=>[kind=>..., state=>..., dests=>[...], from=>[...]
my %processors=(""=>\&broadcast, "%"=>\&flipflop, "&"=>\&conjunction, "END"=>\&end);
my %negate_pulse=qw(low high high low);
my %flip_state=qw(off on on off);

while(<>){ # Read
    die "Wrong format" unless /^\s*(\W)?(\w+)\s*->\s*(.*?)\s*$/;
    my ($kind, $name, $dests)=($1//"", $2, $3);
    my @dests=split /\s*,\s*/, $dests;
    create($name, $kind, [@dests], $processors{$kind});
}
#create("output", "END", [], $processors{END});

for(keys %modules){ # initialize
    my $module=$modules{$_};
    $module->{state}="off" if $module->{kind} eq "%";
    do {$module->{state}{$_}="low" for $module->{from}->@*}
       if $module->{kind} eq "&";
}

my $iter=0;
my %count=(low=>0, high=>0);
my @queue;
my @nextqueue;
while($iter++<$N){
    push @queue, ["button", "low", "broadcaster"];
    while(@queue){
	my $next=shift @queue;
	++$count{$next->[1]};
	dispatch($next);
    }
}
my $total=$count{low}*$count{high};
say $total;

sub create($name, $kind, $dests, $processor){
    $modules{$name}//={};
    $modules{$name}={$modules{$name}->%*,
			 kind=>$kind,dests=>$dests, processor=>$processor};
    # push $modules{$_}{from}->@*, $name for @$dests;
    my $end_processor=$processors{"END"};
    for(@$dests){
	$modules{$_}//={kind=>"END", processor=>$end_processor};
	push $modules{$_}{from}->@*, $name;
    }
}
sub dispatch($instruction){
    my ($from, $pulse, $target)=@$instruction;
    my $processor=$modules{$target}{processor};
    $processor->($from, $pulse, $target)
}
sub broadcast($from, $pulse, $self){
    push @queue, [$self, $pulse, $_] for $modules{$self}{dests}->@*;
}
sub flipflop($from, $pulse, $self){
    my $flipflop=$modules{$self};
    return if $pulse eq "high";
    $flipflop->{state}=$flip_state{my $old_state=$flipflop->{state}};
    my $nextpulse=$old_state eq "off"?"high":"low";
    push @queue, [$self, $nextpulse, $_] for $flipflop->{dests}->@*;
}
sub conjunction($from, $pulse, $self){
    my $conjunction=$modules{$self};
    my $state=$conjunction->{state};
    $state->{$from}=$pulse;
    my $nextpulse=(all {$_ eq "high"} values $state->%*)?"low":"high";
    push @queue, [$self, $nextpulse, $_] for $conjunction->{dests}->@*;
}
sub end($from, $pulse, $self){
}


#+end_src

The code is ugly and maybe with more patience and using classes it may
look better, but it runs in 100ms.

*** Task b
I made the a trivial modification to the code above, running until rx
receives a low pulse, but it took forever without finishing. I guess a
smarter solution consists of determining the period of each module and
finding the lowest common multiple of the appropriate cycles.

Although I haven't solved the general case, I noticed that
the last module, rx, only receives signals from one module, qn which
is a conjunction that only receives signals from modules qz, cq, jx
and tt. It turns out that thoses modules seem to send a high signal periodically
with no offset. For example, in my case, qz sends a high signal after the button
is pressed 3911, 7822, 11733, 15644... times, i.e., each 3911 times
counting from zero. Similarly for the other modules:
| qz | 3911 |
| cq | 4021 |
| jx | 3907 |
| tt | 3931 |
Thus, the result is the least common multiplier
241,528,477,694,627. The program that computes this number follows

#+begin_src perl  :tangle 20b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all);
use Math::Prime::Util qw(lcm);
my %modules; #name=>[kind=>..., state=>..., dests=>[...], from=>[...]
my %processors=(""=>\&broadcast, "%"=>\&flipflop, "&"=>\&conjunction, "END"=>\&end);
my %negate_pulse=qw(low high high low);
my %flip_state=qw(off on on off);

while(<>){ # Read
    die "Wrong format" unless /^\s*(\W)?(\w+)\s*->\s*(.*?)\s*$/;
    my ($kind, $name, $dests)=($1//"", $2, $3);
    my @dests=split /\s*,\s*/, $dests;
    create($name, $kind, [@dests], $processors{$kind});
}

for(keys %modules){ # initialize
    my $module=$modules{$_};
    $module->{state}="off" if $module->{kind} eq "%";
    do {$module->{state}{$_}="low" for $module->{from}->@*}
       if $module->{kind} eq "&";
}
my $count=0;
my $lasatlast="rx";
my $last=$modules{rx}->{from}[0];               # qn
my @penultimate=$modules{$last}{from}->@*; 	#/qz|cq|jx|tt/

my %periods;
my @queue;
my @nextqueue;
COUNT: while(1){
    push @queue, ["button", "low", "broadcaster"];
    ++$count;
    while(@queue){
	my $next=shift @queue;
	do {$periods{$_}=$count if $next->[0] eq $_ && $next->[2] eq "qn"
	    && $next->[1] eq "high" && !defined $periods{$_}} for @penultimate;
	last COUNT if all {defined $periods{$_}} @penultimate;
	dispatch($next);
    }
}
say "$_ $periods{$_}" for @penultimate;
say "Result: ", lcm(map {$periods{$_}} @penultimate);

sub create($name, $kind, $dests, $processor){
    $modules{$name}//={};
    $modules{$name}={$modules{$name}->%*,
			 kind=>$kind,dests=>$dests, processor=>$processor};
    # push $modules{$_}{from}->@*, $name for @$dests;
    my $end_processor=$processors{"END"};
    for(@$dests){
	$modules{$_}//={kind=>"END", processor=>$end_processor};
	push $modules{$_}{from}->@*, $name;
    }
}
sub dispatch($instruction){
    my ($from, $pulse, $target)=@$instruction;
    my $processor=$modules{$target}{processor};
    $processor->($from, $pulse, $target)
}
sub broadcast($from, $pulse, $self){
    push @queue, [$self, $pulse, $_] for $modules{$self}{dests}->@*;
}
sub flipflop($from, $pulse, $self){
    my $flipflop=$modules{$self};
    return if $pulse eq "high";
    $flipflop->{state}=$flip_state{my $old_state=$flipflop->{state}};
    my $nextpulse=$old_state eq "off"?"high":"low";
    push @queue, [$self, $nextpulse, $_] for $flipflop->{dests}->@*;
}
sub conjunction($from, $pulse, $self){
    my $conjunction=$modules{$self};
    my $state=$conjunction->{state};
    $state->{$from}=$pulse;
    my $nextpulse=(all {$_ eq "high"} values $state->%*)?"low":"high";
    push @queue, [$self, $nextpulse, $_] for $conjunction->{dests}->@*;
}
sub end($from, $pulse, $self){
}


#+end_src

#+RESULTS:

** Day 21
https://adventofcode.com/2023/day/21
*** Task a
Use even-odd, 0, 1
#+begin_src perl  :tangle 21a.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use List::Util qw(sum0);
use bigint;
my @dirs=map {pdl $_} ([0,1],[1,0],[-1,0],[0,-1]);
my $start;
my $N=64;
my %type;
my $y=0;
my $xmax;
while(<>){
    chomp;
    my @line=split "";
    $xmax//=@line;
    my $x=0;
    for(@line){
	my $coords=pdl[$y,$x];
	$type{$coords}=/S/?0:$_;
	$start=$coords if(/S/);
	++$x;
    }
    ++$y;
}
my $ymax=$y;
my $tl=pdl[0,0];
my $br=pdl[$ymax,$xmax];
my @pending;
my @next_pending;
push @pending, $start;
for(1..$N){
    my $parity=$_%2;
    while(@pending){
	my $current=shift @pending;
	for(@dirs){
	    my $coords=$current+$_;
	    next unless ($coords>=$tl)->all && ($coords<$br)->all;
	    push(@next_pending, $coords), $type{$coords}=$parity if $type{$coords} eq ".";
	}
    }
    @pending=@next_pending;
    @next_pending=();
}
my $final_parity=$N%2;
my $count=sum0 map {~~($type{$_} eq $final_parity)} keys %type;
say "$count";

#+end_src


*** Task b
The previous solution would not scale for the second task.

Notice that for the input data the starting point is right at the
center of the map and that there are /highways/ through the starting
position with no stones along the horizontal and vertical
directions. Thus the map is neatly divided into four quadrants, say
NE, NW, SW and SE. I can also divide into four quadrants the
infinitely repeated map. I consider one of those semiinfinite
quadrants, say SE. The length of the shortest route to any plot in
that quadrant is the length along the highway to the NW corner of its
small quadrant plus the length of shortest route from that corner to the
plot. Call that length the distance in the taxi-driver's metric. Thus,
if I start at the starting point S and take M steps, if M is larger
than than the largest distance within a quadrant, its diameter, all of its plots may
be reached with M or less steps. With exactly M steps, all the plots
with the same parity as M (odd or even) may be reached. That is,
around about half the area minus the number of odd or even numbered
rocks. If M is smaller than the diameter, then the answer is the
number of even or odd plots that may be reached in M steps.
Then I may subtract the width of the quadrant from M and
consider the quadrant to the east, or subtract the height and consider
the quadrant to the north. I can use modular arithmetic to skip
rapidly over the closest quarters.

As I always move towards the east and south, I have to guarantee that
I don't need to go around obstacles. As I reshuffle the quadrants, I
no longer have rock-free 'highways' along the eastmost or southmost
rows. Thus I duplicate extra highways for computing the required
number of steps to each site, which I have to remove afterwards.

As the shortest entry point to any block of quadrants is its NW
corner, I can speed up the calculation with the following observation:

#+begin_example
FFFFFFabE
FFFFFabEE
FFFFabEEE
FFFabEEEE
FFabEEEEE
FabEEEEEE
abEEEEEEE
aEEEEEEEE
#+end_example
There are full blocks, where all the plots have been visited,
blocks like a and b with partially visited plots and plots like E
which have not been visited. Thus I need only compute one full block,
distinguishing even from odd sites, and the few partially visited
plots like a and B. In the example above there are N*(N+1)/2 full
plots, where N is the number of full plots along the horizontal. The
solution is more subtle, as I have to count separately those plots
where I enter after an odd and after an even number of steps.


I represent each quadrant by numbers, -2 for plots that haven't been
measured, -1 for stones and a non-negative number giving the distance
to its SW corner.


#+begin_src perl   :tangle 21b.pl :shebang #!/usr/bin/env perl
use v5.36;
use PDL;
use PDL::NiceSlice;
die unless @ARGV==2;
my $M=shift;
#my $M=26501365;
my @dirs=map {pdl $_} ([0,1],[1,0],[-1,0],[0,-1]);
my $start;
my $map;
my @map;
my %type;
my $y=0;
my $xmax;
while(<>){
    chomp;
    last if /^$/;
    my @line=split "";
    s/S/0/ || s/#/-1/ || s /./-2/ for @line;
    push @map, [@line];
}
$map=pdl(@map);
my ($width,$height)=map {$map->dim($_)} (0,1);
my ($cx, $cy)=map {($_-1)/2} ($width,$height);
# check assumptions
die "Wrong assumptions" unless
    $map($cx, $cy) == 0
    && ($map($cx,  0:$cy-1)==-2)->all
    && ($map($cx, $cy+1:-1)==-2)->all
    && ($map(0:$cx-1,  $cy)==-2)->all
    && ($map($cx+1:-1, $cy)==-2)->all;
# Put start at 0,0 NW, y grows downward
my $count=compute_SE($map); # southeast
$count+=compute_SE($map(-1:0)); # and reflections for other quadrants
$count+=compute_SE($map(:,-1:0));
$count+=compute_SE($map(-1:0,-1:0));
$count -=2*$M+3 if $M%2==0; # don't double count axes and origin
$count -=2*($M+1) if $M%2==1;
say $count;

sub compute_SE($map){
    my ($SE, $SW, $NE, $NW)= map {$_->copy}
	( # Note shuffling. NW contains starting point. Note overlapping highways
	  $map(0:$cx,0:$cy),  $map($cx:2*$cx,0:$cy),
	  $map(0:$cx,$cy:2*$cy),$map($cx:2*$cx,$cy:2*$cy));
    my $count=compute_aux($NW, $NE, $SW, $SE);
    return $count;
}

sub compute_aux($NW, $NE, $SW, $SE){ #
    $_.=-2 for ($NE((-1),:), $SW(:,(-1)), $SE((-1),:), $SE(:,(-1))); # add highway plots
    prepare($_) for ($NW, $NE, $SW, $SE);
    # remove added highways:
    $NE=$NE(0:-2,    );
    $SW=$SW( :  ,0:-2);
    $SE=$SE(0:-2,0:-2);
    my ($wx, $wy)=$NW->dims;
    my @regions=(
	{name=>"NW", map=>$NW,  offset=>pdl(0,0),     diameter=>$NW->max,
	 plots=>which($NW>=0)->nelem},
	{name=>"NE", map=>$NE,  offset=>pdl($wx,0),   diameter=>$NE->max,
	 plots=>which($NE>=0)->nelem},
	{name=>"SW", map=>$SW,  offset=>pdl(0,$wy),   diameter=>$SW->max,
	 plots=>which($SW>=0)->nelem},
	{name=>"SE", map=>$SE,  offset=>pdl($wx,$wy), diameter=>$SE->max,
	 plots=>which($SE>=0)->nelem}
	);
    for(@regions){
	my $map=$_->{map};
	my %count;
	++$count{$_} for grep {$_>=0} $map->list;
	# accumulate even and odd counts
	$count{$_}+=$count{$_-2} for 2..$_->{diameter};
	$_->{count}={%count};
    }
    my $superdiameter=pdl(map{$_->{offset}->sumover+$_->{diameter}} @regions)->max;
    my $superplots=pdl(map{$_->{plots}} @regions)->sum;
    my $count=0;
    my @border;
    my $bxmax=my $bx=floor($M/$width);
    my $need=$M-$bx*$width;
    while($bx>=0 && 0<=$need<=$superdiameter){
	my $block=0;
	$block+=compute_one($need, $_) for(@regions);
	push @border, $block;
	--$bx;
	$need+=$width;
    }
    # Now bx is the farthest block that has to be counted completely
    my ($withcorner, $withoutcorner);
    ($withcorner, $withoutcorner)=(($bx+2)**2/4, $bx*($bx+2)/4) if $bx%2==0;
    ($withcorner, $withoutcorner)=(($bx+1)**2/4, ($bx+1)*($bx+3)/4)  if $bx%2==1;
    my ($even, $odd)=$M%2==0?($withcorner, $withoutcorner):($withoutcorner, $withcorner);
    my ($plotseven, $plotsodd)=$superplots%2==0
	?($superplots/2,     $superplots/2)
	:(($superplots+1)/2, ($superplots-1)/2);
    $count = $plotseven*$even+$plotsodd*$odd;
    #there are $bx+1 columns of @border partial blocks blocks
    my $boundary=($bx+1)*pdl(@border)->sum;
    # there are 1..@border blocks at the corner
    while(@border){
	$boundary+=pdl(@border)->sum;
	pop @border;
    }
    $count+=$boundary;
    return $count;
}

sub compute_one($steps, $region){
    my $pending_steps = $steps-$region->{offset}->sumover; # move to start
    #my $map=$region->{map};
    #my $result=which(($map>=0) & ($map <= $pending_steps) & (($pending_steps-$map)%2==0))->nelem;
    my $diameter=$region->{diameter};
    my $result;
    if($pending_steps>$diameter){
	$result=$region->{count}{$diameter} if ($pending_steps-$diameter)%2==0;
	$result=$region->{count}{$diameter-1} if ($pending_steps-$diameter)%2==1;
    }else{
	$result=$region->{count}{$pending_steps};
    }
    $result//=0;
    return $result;
}

sub prepare($map){
    # set distances from upper left corner 0 based
    my $last=pdl $map->dims;
    my $neighbors=pdl[[1,0],[0,1],[-1,0],[0,-1]];
    my @pending;
    push @pending, [0,pdl(0,0)];
    $map(0,0).=0;

    while(@pending){
	my ($d, $r)=(shift @pending)->@*;
	++$d;
	for(($r+$neighbors)->dog){
	    next if(($_<0) | ($_>=$last))->orover;
	    my ($x, $y)=$_->dog;
	    my $site=$map($x,$y);
	    next if $site==-1; #skip rocks
	    next if $site != -2 && $site <= $d; #already visited
	    $site.=$d; #update neighbors
	    push @pending, [$d, $_]; #schedule neighbors
	}
    }
}

#+end_src
