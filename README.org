* Advent of code
Trying my luck for the first time with the [[https://adventofcode.com/2023/about][Advent of Code]] 2023.
** Day 1
https://adventofcode.com/2023/day/1
*** Task a
Use non-greedy regular expressions to get the first and last digits of
each row

#+begin_src perl :tangle 1a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
while(<>){
    /^.*?(\d)/ and my $f=$1 or die;
    /.*(\d).*?$/ and my $l=$1 or die;
    $tot += "$f$l";
}
say $tot;
#+end_src
*** Task b
Make a regular expression to identify digits and digit names.
#+begin_src perl :tangle 1b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
use v5.36;
my $tot=0;
my @digits=qw(one two three four five six seven eight nine);
my $i=1;
my %digit;
$digit{$_}=$i++ for @digits;
$digit{$_}=$_ for 0..9;
my $digit=join "|", @digits, '\d';
my $first=qr"^.*?($digit)"i;
my $last=qr".*($digit).*?$"i;
while(<>){
    /$first/ and my $f=$1 or die;
    /$last/ and my $l=$1 or die;
    $tot += "$digit{$f}$digit{$l}";
}
say $tot;
#+end_src
** Day 2
https://adventofcode.com/2023/day/2
*** Task a
Use regular expressions to obtain game ids. Split to obtain the
subsets of cubes. Use a regular expression to obtain the number of
cubes of each color and check if there are enough cubes in the bag.
#+begin_src perl :tangle 2a.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum possible game ids for 12 red cubes, 13 green cubes, and 14 blue cubes
use v5.36;
my %available=(red=>12, green=>13, blue=>14);
my $total=0;
while(<>){
    s/Game\s*(\d+):\s*// or die;
    my $id=$1;
    my $impossible=0;
    SUBSET: for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    $impossible=1,last SUBSET if $quantity>$available{$color};
	}
    }
    $total += $id unless $impossible;
}
say $total;
#+end_src
*** Task b
Use a regular expression and split to obtain the subsets. Adjust the
minimum number of cubes necessary to fullfill all samples, multiply
them and add.

#+begin_src perl :tangle 2b.pl :shebang #!/usr/bin/env perl
#!/usr/bin/env perl
# Sum minimum powers of games
use v5.36;
use List::Util qw(product);
my $total=0;
while(<>){
    s/Game\s*\d+:\s*// or die;
    my %minima=(red=>0, green=>0, blue=>0);
    for(split /\s*;\s*/){
	for(split /\s*,\s*/){
	    /^(\d+)\s*(.*)$/  or die;
	    my ($quantity, $color)=($1, $2);
	    ($_<$quantity) && ($_=$quantity) for $minima{$color};
	}
    }
    my $product=product values %minima;
    $total += $product;
}
say $total;
#+end_src
** Day 3
https://adventofcode.com/2023/day/3
*** Task a
Read the schematics into an array. Add dots "." at the boundaries as
guards. For each symbol, mark as valid its nearest
neighbors. Accumulate all numbers, i.e., strings of digits, that
overlap a valid cell.

#+begin_src perl :tangle 3a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $symbol=qr([^\.\d]);
my @schematic;
my @valid; # valid sites
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    push @schematic, [@row];
    push @valid, [(0) x $width];
}
push @schematic, [(".") x $width];  # add initial, final boundaries
unshift @schematic, [(".") x $width];
push @valid, [(0) x $width];
unshift @valid, [(0) x $width];
for my $i(1..@schematic-2){
    for my $j(1..$width-2){
	next unless $schematic[$i][$j]=~/$symbol/;
	for my $k(-1,0,1){     # validate neighbors of symbols
	    for my $l(-1,0,1){
		$valid[$i+$k][$j+$l]=1;
	    }
	}
    }
}
my $total=0;
for my $i(1..@schematic-2){
    my @row=@{$schematic[$i]};
    my @valid_row=@{$valid[$i]};
    my $number=0;
    my $valid=0;
    for my $j(1..$width-2){
	$valid||=$valid_row[$j], $number=10*$number+$row[$j], next if $row[$j]=~/\d/;
	$total+=$number if $valid;
	$number=0;
	$valid=0
    }
    $total+=$number if $valid;
    $number=0;
    $valid=0;
}
say $total;
#+end_src
*** Task b
Index all part numbers, i.e., strings of digits, by pushing them into
an array. For each gear, identify the part indices of the neighboring
parts. If there are exactly two, multiply them and accumulate the product.

#+begin_src perl :tangle 3b.pl :shebang #!/usr/bin/env perl
use v5.36;
my $gear=qr(\*);
my @schematic;
my @parts;
my $width;
while(<>){
    chomp;
    my @row=(".", split(""), ".");  # add left, right boundaries
    $width//=@row;
    die "Equal length lines expected" unless $width==@row;
    my $number;
    for(@row){
	if(/\d/){
	    $number//=0;
	    $number=10*$number+$_;
	    $_=@parts; # part index
	}else{
	    push @parts, $number if defined $number;
	    undef $number;
	}
    }
    push @schematic, [@row];
}
push @schematic, [(".") x @{$schematic[0]}];  # add initial, final boundaries
unshift @schematic, [(".") x @{$schematic[0]}];
my $total=0;
for my $i(1..@schematic-2){
    for my $j(1..$width-1){
	next unless $schematic[$i][$j]=~/$gear/;
	my %neighbors;
	for my $k(-1,0,1){
	    for my $l(-1,0,1){
		$neighbors{$schematic[$i+$k][$j+$l]}=1 if $schematic[$i+$k][$j+$l]=~/\d/;
	    }
	}
	my @neighbors=keys %neighbors;
	next unless @neighbors==2; # exactly two neighbors
	$total+=$parts[$neighbors[0]]*$parts[$neighbors[1]];
    }
}
say $total;
#+end_src
** Day 4
https://adventofcode.com/2023/day/4
*** Task a
I use a regular expression to throw away the card numbers and separate
the winning from the card numbers. I split those numbers on space. I
make a hash of winning numbers to check against the card numbers and
find how many matches m I get. If m==0, the score of that card is 0,
otherwise, it is 2^{m-1}.

#+begin_src perl :tangle 4a.pl :shebang #!/usr/bin/env perl
use v5.36;
my $total=0;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    my $score=0;
    $score=1<<($matches-1) if $matches;
    $total += $score;
}
say $total;
#+end_src

*** Task b
I use the previous task to obtain how many numbers match the winning
numbers of each card and save that in an array. I start with one card
each. For each card number I keep an array of how many cards I have
and add that many cards to the number of following cards, according to
the score. I guess the code is clearer than this description.
#+begin_src perl :tangle 4b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(sum0);
my @scores;
while(<>){
    chomp;
    die unless /.*:\s*(.*)\s*\|\s*(.*)\s*/;
    my @winning=split " ", $1;
    my @mine=split " ", $2;
    my %winning;
    $winning{$_}=1 for @winning;
    my $matches=0;
    $winning{$_} && ++$matches for(@mine);
    push @scores, $matches;
}
my @cards=(1) x @scores;
for(0..@scores-1){
    my $multiplier=$cards[$_];
    $cards[$_] += $multiplier for ($_+1..$_+$scores[$_]);
}
my $cards=sum0 @cards;
say $cards;
#+end_src

** Day 5
https://adventofcode.com/2023/day/5
*** Task a
#+begin_src perl :tangle 5a.pl :shebang #!/usr/bin/env perl
use v5.38;
use experimental 'class';
class Range {
    field $start_source :param;
    field $start_destination :param;
    field $length :param;
    method start_source {$start_source};
    method start_destination {$start_destination};
    method length {$length};
    method end_source {$start_source+$length-1};
    method end_destination {$start_destination+$length-1};
    method in_range($s){$s>=$start_source && $s < $start_source+$length};
    method destination($s){
	return $s-$start_source+$start_destination if $self->in_range($s);
	return $s;
    }
}
class Map {
    use List::Util qw(first);
    field $source :param;
    field $destination :param;
    field %ranges;
    field $ordered=0;
    field @ordered;
    method source {$source};
    method destination {$destination};
    method ranges {values %ranges};
    method add_range($range) {$ordered=0; $ranges{$range->start_source}=$range};
    method sort_range {$ordered=1; @ordered=sort {$b <=> $a} keys %ranges};
    method map($s){
	$self->sort_range unless $ordered;
	my $r=first {$_<=$s} @ordered; # dumb search
	return $s unless defined $r;
	my $range=$ranges{$r};
	$range->destination($s);
    }
}
sub read_map(){
    return if eof;
    while(<>){last unless /^$/;} # skip blank
    return if eof;
    die "Wrong name" unless /^\s*(\w+)-to-(\w+)\s+map:/i;
    my ($source, $destination)=($1,$2);
    my $map=Map->new(source=>$source, destination=>$destination);
    while(<>){
	last if /^$/;
	my ($sd, $ss, $l)=split " ";
	my $range=Range->new(start_source=>$ss, start_destination=>$sd, length=> $l);
	$map->add_range($range);
    }
    return $map;
}
chomp(my $line=<>);
die "Expected seeds" unless $line=~s/^\s*seeds:\s*//i;
my @seeds=split " ", $line;
my %maps;
while(my $map=read_map()){
    $maps{$map->source}=$map;
}
my $location;
my $desired="location";
foreach my $seed(@seeds){
    my $from="seed";
    my $number=$seed;
    while(1){
	my $map=$maps{$from};
	my $to=$map->destination;
	$number=$map->map($number);
	last if $to eq "location";
	$from=$to;
    }
    $location//=$number;
    $location=$number if $number<$location;
}
say $location;
#+end_src
*** Task b
My first attempt was to minimize the location for all seeds, but it
took several hours without finishing. Instead of checking individual seeds, I can
check seed ranges. I use a divide and conquer strategy. If the given
range in the source may be mapped to a single range in the
destination, I push into a queue the destination and the new
range. Otherwise, I cut it in half and retry each half for the same
source. The code follows, but it can be cleaned up. For the first time
I used the new ~class~ feature.


#+begin_src perl :tangle 5b.pl :shebang #!/usr/bin/env perl
use v5.38;
use experimental qw(class for_list);
use POSIX qw(floor);
class Range {
    field $start_source :param;
    field $start_destination :param;
    field $length :param;
    method start_source {$start_source};
    method start_destination {$start_destination};
    method length {$length};
    method end_source {$start_source+$length-1};
    method end_destination {$start_destination+$length-1};
    method in_range($s){$s>=$start_source && $s < $start_source+$length};
    method destination($s){
	return $s-$start_source+$start_destination if $self->in_range($s);
	return $s;
    }
}
class Map {
    use List::Util qw(first);
    field $source :param;
    field $destination :param;
    field %ranges;
    field $ordered=0;
    field @ordered;
    method source {$source};
    method destination {$destination};
    method ranges {values %ranges};
    method add_range($range) {$ordered=0; $ranges{$range->start_source}=$range};
    method sort_range {$ordered=1; @ordered=sort {$b <=> $a} keys %ranges};
    method range_before($s){
	$self->sort_range unless $ordered;
	my $r=first {$_<=$s} @ordered; # dumb search
	return unless defined $r;
	return $ranges{$r};
    }
    method range_after($s){
	$self->sort_range unless $ordered;
	my $r=first {$_>$s} reverse @ordered;
	return unless $r;
	return $ranges{$r};
    }
    method destination_of($s){
	my $range=$self->range_before($s);
	$self->sort_range unless $ordered;
	return $s unless defined $range;
	$range->destination($s);
    }
}
sub read_map(){
    return if eof;
    while(<>){last unless /^$/;} # skip blank
    return if eof;
    die "Wrong name" unless /^\s*(\w+)-to-(\w+)\s+map:/i;
    my ($source, $destination)=($1,$2);
    my $map=Map->new(source=>$source, destination=>$destination);
    while(<>){
	last if /^$/;
	my ($sd, $ss, $l)=split " ";
	my $range=Range->new(start_source=>$ss, start_destination=>$sd, length=> $l);
	$map->add_range($range);
    }
    return $map;
}
chomp(my $line=<>);
die "Expected seeds" unless $line=~s/^\s*seeds:\s*//i;
my @seeds=split " ", $line;
my %maps;
while(my $map=read_map()){
    $maps{$map->source}=$map;
}
my $best_location;
my $desired="location";
my @pending;
foreach my ($seed, $seed_nvals)(@seeds){
    push @pending, ["seed", $seed, $seed_nvals];
    while(@pending){
	my $source_range=shift @pending;
	my ($source, $initial, $nvals)=@$source_range;
	my $final=$initial+$nvals-1;
	if($source eq $desired){
	    $best_location //= $initial;
	    $best_location=$initial if $initial < $best_location;
	    next;
	}
	my $map=$maps{$source};
	my $destination=$map->destination;
	my $range0=$map->range_before($initial);
	my $range1=$map->range_after($initial);
	undef $range0 if defined $range0 and $range0->end_source < $initial;
	my $half=floor $nvals/2;
	if(not defined $range0){
	    push(@pending, [$destination, $initial, $nvals]), next if not defined $range1;
	    push(@pending, [$destination, $initial, $nvals]), next
		if $final < $range1->start_source;
	    push(@pending, [$source, $initial, $half]);
	    push(@pending, [$source, $initial+$half, $nvals-$half]);
	    next;
	}
	push(@pending, [$destination, $map->destination_of($initial), $nvals]), next
	    if $final <= $range0->end_source;
	push(@pending, [$source, $initial, $half]);
	push(@pending, [$source, $initial+$half, $nvals-$half]);
    }
}
say $best_location;
#+end_src
** Day 6
https://adventofcode.com/2023/day/6
*** Task a
The distance d travelled is equal to the speed v times the available
time (t-v), where t is the total time and the held time is equal to
the speed. Thus, d=vt-v^2. I need d>d_0. Thus, I solve the quadratic
equation v^2-vt-d_0 = 0, and the held time is bounded by the two
solutions.

#+begin_src perl :tangle 6a.pl :shebang #!/usr/bin/env perl
use v5.36;
use POSIX qw(floor ceil);
chomp(my $times=<>);
die "Bad times" unless $times=~s/^\s*Time:\s*(.*)\s*$/$1/i;
my @times=split " ", $times;
chomp(my $distances=<>);
die "Bad distances" unless $distances=~s/^\s*Distance:\s*(.*)\s*/$1/i;
my @distances=split " ", $distances;
die "Wrong dimensions" unless @times==@distances;
my $total=1;
for(0..@times-1){
    my $t=$times[$_];
    my $x=$distances[$_];
    my $s=sqrt($t**2-4*$x);
    my $v0=ceil(($t-$s)/2);
    my $v1=floor(($t+$s)/2);
    my $ways=$v1-$v0+1;
    $ways-=2 if $s==floor($s);
    $total*=$ways;
}
say $total;

#+end_src

*** Task b

#+begin_src perl :tangle 6b.pl :shebang #!/usr/bin/env perl
use v5.36;
use POSIX qw(floor ceil);
chomp(my $t=<>);
die "Bad times" unless $t=~s/^\s*Time:\s*(.*)\s*$/$1/i;
chomp(my $x=<>);
die "Bad distances" unless $x=~s/^\s*Distance:\s*(.*)\s*/$1/i;
s/\s+//g for ($t, $x);
my $s=sqrt($t**2-4*$x);
my $v0=ceil(($t-$s)/2);
my $v1=floor(($t+$s)/2);
my $ways=$v1-$v0+1;
$ways-=2 if $s==floor($s);
say $ways;

#+end_src

** Day 7
https://adventofcode.com/2023/day/7
*** Task a
I make an ranked array of card values and of possible games, each
characterized by an array with ordered card patterns, i.e. [5] (five
of a kind) [4,1] (four of a kind), [3,2] (full house), etc. I build an
array of hands. Each and is characterized by its string representation
and the bid, taken from the input data, the score of the hand
according to their type and an array of the values of each card. Then,
I rank all games by sorting on their scores and if necessary on their
values.

#+begin_src perl :tangle 7a.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0 first);
my @cards=qw(2 3 4 5 6 7 8 9 T J Q K A);
my %value;
$value{$cards[$_]}=$_ for 0..@cards-1;
my @games=([1,1,1,1,1], [2,1,1,1], [2,2,1], [3,1,1], [3,2], [4,1], [5]);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=score(card_numbers($hand));
    my $values=[map {$value{$_}} split "", $hand];
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {by_hand($a, $b) || by_cards($a, $b)} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub by_hand {
    my $cmp= $a->[2] <=> $b->[2];
    return $cmp;
}

sub by_cards {
    my ($va, $vb)=map {$_->[3]} ($a, $b);
    my $cmp=first {$_} map {$va->[$_] <=> $vb->[$_]} (0..@$va-1);
    return $cmp//0;
}

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    return [sort {$b<=>$a} values %m];
}

sub score($c){
    my $nc=@$c;
    for(0..@games-1){
	my $g=$games[$_];
	my $ng=@$g;
	next unless $ng==$nc;
	return $_ if all {$g->[$_] eq $c->[$_]} 0..$ng-1;
    }
    die "Shouldn't reach";
}
#+end_src

*** Task b
The solution is almost identical, but if a hand has jokers besides
other cards, the number of jokers is added to the card that is
repeated the most before scoring.

#+begin_src perl :tangle 7b.pl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0 first);
my @cards=qw(J 2 3 4 5 6 7 8 9 T Q K A);
my %value;
$value{$cards[$_]}=$_ for 0..@cards-1;
my @games=([1,1,1,1,1], [2,1,1,1], [2,2,1], [3,1,1], [3,2], [4,1], [5]);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=score(card_numbers($hand));
    my $values=[map {$value{$_}} split "", $hand];
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {by_hand($a, $b) || by_cards($a, $b)} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub by_hand {
    my $cmp= $a->[2] <=> $b->[2];
    return $cmp;
}

sub by_cards {
    my ($va, $vb)=map {$_->[3]} ($a, $b);
    my $cmp=first {$_} map {$va->[$_] <=> $vb->[$_]} (0..@$va-1);
    return $cmp//0;
}

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    my @sorted=sort {$m{$b}<=>$m{$a}} keys %m;
    for(0..@sorted-1){
	if($sorted[$_] eq "J"){
	    my $add=$m{"J"};
	    if(@sorted>1){ # if other cards
		splice @sorted, $_, 1; # add J to others
		$m{$sorted[0]} += $add;
	    }
	    last;
	}
    }
    return [map {$m{$_}} @sorted];
}

sub score($c){
    my $nc=@$c;
    for(0..@games-1){
	my $g=$games[$_];
	my $ng=@$g;
	next unless $ng==$nc;
	return $_ if all {$g->[$_] eq $c->[$_]} 0..$ng-1;
    }
    die "Shouldn't reach";
}
#+end_src
#+begin_src perl :shebang #!/usr/bin/env perl
use v5.36;
use List::Util qw(all sum0);
my @cards=qw(J 2 3 4 5 6 7 8 9 T Q K A);
my %value;
$value{$cards[$_]}=$_ for 0..@cards-1;
my @games=([1,1,1,1,1], [2,1,1,1], [2,2,1], [3,1,1], [3,2], [4,1], [5]);
my @hands;
while(<>){
    chomp;
    my($hand, $bid)=split " ";
    my $score=score(card_numbers($hand));
    my $values=[map {$value{$_}} split "", $hand;
    push @hands, [$hand, $bid, $score, $values];
}
my @sorted=sort {by_hand($a, $b) || by_cards($a, $b)} @hands;
my $result= sum0 map {($_+1)*$sorted[$_][1]} 0..@sorted-1;
say $result;

sub by_hand {
    my ($sa, $sb)=map {$_->[3]} ($a, $b);
    my $cmp= $sa <=> $sb;
    return $cmp;
}

sub by_cards {
    my ($va, $vb)=map {$_->[3]} ($a, $b);
    for(0..@$va-1){
	my $cmp=$va->[$_] <=> $vb->[$_];
	return $cmp if $cmp
    }
    return 0;
}

sub card_numbers($h){
    my %m;
    ++$m{$_} for split "", $h;
    my @sorted=sort {$m{$b}<=>$m{$a}} keys %m;
    for(0..@sorted-1){
	if($sorted[$_] eq "J"){
	    my $add=$m{$sorted[$_]};
	    splice @sorted, $_, 1;
	    $sorted[0] += $add;
	    last;
	}
    }
    return [@sorted];
}

sub score($c){
    my $nc=@$c;
    for(0..@games-1){
	my $g=$games[$_];
	my $ng=@$g;
	next unless $ng==$nc;
	return $_ if all {$g->[$_] eq $c->[$_]} 0..$ng-1;
    }
    die "Shouldn't reach";
}
#+end_src
#+end_src
